{
    "reserved_word_dictionary": {
        "package": "Used to declare a package."
    },
    "identifier_dictionary": {
        "e": null,
        "file": null,
        "blocker": null,
        "indexingTaskManager": null,
        "files": null,
        "entry": null,
        "linkedfile": null,
        "relativePath": null,
        "type": null,
        "targetFile": null,
        "firstExistingFileDir": null,
        "bibDatabaseContext": null,
        "filePreferences": null,
        "renameFilesCleanup": null,
        "moveFilesCleanup": null,
        "LOGGER": null,
        "nonWrappableFields": null,
        "field": null,
        "defaultGeneralFields": null,
        "fields": null,
        "selector": null,
        "standardFieldsWithBibtexKey": null,
        "allFields": null,
        "publicAndInternalFields": null,
        "fieldName": null,
        "fieldNames": null,
        "DELIMITER": null,
        "FIELD_OR_SEPARATOR": null,
        "expectedParserResult": null,
        "parserResult": null,
        "texFile3": null,
        "texFile2": null,
        "texFile": null,
        "latexParserResult": null,
        "citeString": null,
        "key": null,
        "UNKNOWN": null,
        "UNRESOLVED": null,
        "EINSTEIN_C": null,
        "EINSTEIN_A": null,
        "NEWTON": null,
        "EINSTEIN": null,
        "DARWIN": null,
        "dataWithSubTitle": null,
        "dataSubtitle": null,
        "dataTitle": null,
        "fetchedEntry": null,
        "stringSimilarity": null,
        "entryTitle": null,
        "fetchedEntries": null,
        "inputEntry": null,
        "authors": null,
        "exception": null,
        "item": null,
        "i": null,
        "entries": null,
        "items": null,
        "response": null,
        "uriBuilder": null,
        "identifier": null,
        "luceneQuery": null,
        "REMOVE_BRACES_FORMATTER": null,
        "API_URL": null,
        "serializedEntries": null,
        "writer": null,
        "content": null,
        "string": null,
        "fallbackPlain": null,
        "html": null,
        "contents": null,
        "result": null,
        "newValue": null,
        "input": null,
        "preferencesService": null,
        "primary": null,
        "clipboard": null,
        "XML": null,
        "listener": null,
        "autosaveManager": null,
        "event": null,
        "needsSave": null,
        "executor": null,
        "workerQueue": null,
        "changeFilter": null,
        "eventBus": null,
        "runningInstances": null,
        "DELAY_BETWEEN_AUTOSAVE_ATTEMPTS_IN_SECONDS": null,
        "c": null,
        "oldValue": null,
        "observable": null,
        "updateB": null,
        "updateA": null,
        "property": null,
        "mapProperty": null,
        "updating": null,
        "listProperty": null,
        "update": null,
        "propertyB": null,
        "propertyA": null,
        "subscriber": null,
        "other": null,
        "value": null,
        "condition": null,
        "list": null,
        "mapToB": null,
        "binding": null,
        "updateList": null,
        "mapToList": null,
        "mapBtoA": null,
        "mapAtoB": null,
        "mapper": null,
        "source": null,
        "subscription": null,
        "changePseudoClass": null,
        "pseudoClass": null,
        "node": null
    },
    "import_dictionary": {
        "org.jabref.gui.externalfiles": null,
        "org.jabref.gui.externalfiletype.ExternalFileType": null,
        "org.jabref.gui.externalfiletype.ExternalFileTypes": null,
        "org.jabref.gui.externalfiletype.UnknownExternalFileType": null,
        "org.jabref.logic.cleanup.MoveFilesCleanup": null,
        "org.jabref.logic.cleanup.RenamePdfCleanup": null,
        "org.jabref.logic.pdf.search.indexing.IndexingTaskManager": null,
        "org.jabref.logic.pdf.search.indexing.PdfIndexer": null,
        "org.jabref.logic.util.io.FileUtil": null,
        "org.jabref.model.database.BibDatabaseContext": null,
        "org.jabref.model.entry.BibEntry": null,
        "org.jabref.model.entry.LinkedFile": null,
        "org.jabref.preferences.FilePreferences": null,
        "org.slf4j.Logger": "Logger (SLF4J javadoc) JavaScript is disabled on your browser. Skip navigation links Overview Package Class Use Tree Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field | Constr\u00a0| Method Detail: Field | Constr\u00a0| Method SEARCH Package org.slf4j Interface Logger All Known Subinterfaces: LocationAwareLogger All Known Implementing Classes: AbstractLogger , EventRecordingLogger , JDK14LoggerAdapter , LegacyAbstractLogger , LocLogger , LoggerWrapper , MarkerIgnoringBase , NOPLogger , Reload4jLoggerAdapter , SimpleLogger , SubstituteLogger , XLogger public interface Logger The org.slf4j.Logger interface is the main user entry point of SLF4J API.\n It is expected that logging takes place through concrete implementations\n of this interface. Typical usage pattern: import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n\n public class Wombat { final static Logger logger = LoggerFactory.getLogger(Wombat.class); Integer t;\n   Integer oldT;\n\n   public void setTemperature(Integer temperature) {\n     oldT = t;\n     t = temperature; logger.debug(\"Temperature set to {}. Old temperature was {}.\", t, oldT); if (temperature.intValue() > 50) { logger.info(\"Temperature has risen above 50 degrees.\"); }\n   }\n } Note that version 2.0 of the SLF4J API introduces a fluent api ,\n the most significant API change to occur in the last 20 years. Be sure to read the FAQ entry relating to parameterized\n logging . Note that logging statements can be parameterized in presence of an exception/throwable . Once you are comfortable using loggers, i.e. instances of this interface, consider using MDC as well as Markers . Author: Ceki G\u00fclc\u00fc Field Summary Fields Modifier and Type Field Description static final String ROOT_LOGGER_NAME Case-insensitive String constant used to retrieve the name of the root logger. Method Summary All Methods Instance Methods Abstract Methods Default Methods Modifier and Type Method Description default LoggingEventBuilder atDebug () Entry point for fluent-logging for Level.DEBUG level. default LoggingEventBuilder atError () Entry point for fluent-logging for Level.ERROR level. default LoggingEventBuilder atInfo () Entry point for fluent-logging for Level.INFO level. default LoggingEventBuilder atLevel ( Level level) Make a new LoggingEventBuilder instance as appropriate for this logger and the\n desired Level passed as parameter. default LoggingEventBuilder atTrace () Entry point for fluent-logging for Level.TRACE level. default LoggingEventBuilder atWarn () Entry point for fluent-logging for Level.WARN level. void debug ( String msg) Log a message at the DEBUG level. void debug ( String format, Object arg) Log a message at the DEBUG level according to the specified format\n and argument. void debug ( String format, Object ...\u00a0arguments) Log a message at the DEBUG level according to the specified format\n and arguments. void debug ( String format, Object arg1, Object arg2) Log a message at the DEBUG level according to the specified format\n and arguments. void debug ( String msg, Throwable t) Log an exception (throwable) at the DEBUG level with an\n accompanying message. void debug ( Marker marker, String msg) Log a message with the specific Marker at the DEBUG level. void debug ( Marker marker, String format, Object arg) This method is similar to debug(String, Object) method except that the\n marker data is also taken into consideration. void debug ( Marker marker, String format, Object ...\u00a0arguments) This method is similar to debug(String, Object...) method except that the marker data is also taken into\n consideration. void debug ( Marker marker, String format, Object arg1, Object arg2) This method is similar to debug(String, Object, Object) method except that the marker data is also taken into\n consideration. void debug ( Marker marker, String msg, Throwable t) This method is similar to debug(String, Throwable) method except that the\n marker data is also taken into consideration. void error ( String msg) Log a message at the ERROR level. void error ( String format, Object arg) Log a message at the ERROR level according to the specified format\n and argument. void error ( String format, Object ...\u00a0arguments) Log a message at the ERROR level according to the specified format\n and arguments. void error ( String format, Object arg1, Object arg2) Log a message at the ERROR level according to the specified format\n and arguments. void error ( String msg, Throwable t) Log an exception (throwable) at the ERROR level with an\n accompanying message. void error ( Marker marker, String msg) Log a message with the specific Marker at the ERROR level. void error ( Marker marker, String format, Object arg) This method is similar to error(String, Object) method except that the\n marker data is also taken into consideration. void error ( Marker marker, String format, Object ...\u00a0arguments) This method is similar to error(String, Object...) method except that the marker data is also taken into\n consideration. void error ( Marker marker, String format, Object arg1, Object arg2) This method is similar to error(String, Object, Object) method except that the marker data is also taken into\n consideration. void error ( Marker marker, String msg, Throwable t) This method is similar to error(String, Throwable) method except that the marker data is also taken into\n consideration. String getName () Return the name of this Logger instance. void info ( String msg) Log a message at the INFO level. void info ( String format, Object arg) Log a message at the INFO level according to the specified format\n and argument. void info ( String format, Object ...\u00a0arguments) Log a message at the INFO level according to the specified format\n and arguments. void info ( String format, Object arg1, Object arg2) Log a message at the INFO level according to the specified format\n and arguments. void info ( String msg, Throwable t) Log an exception (throwable) at the INFO level with an\n accompanying message. void info ( Marker marker, String msg) Log a message with the specific Marker at the INFO level. void info ( Marker marker, String format, Object arg) This method is similar to info(String, Object) method except that the\n marker data is also taken into consideration. void info ( Marker marker, String format, Object ...\u00a0arguments) This method is similar to info(String, Object...) method except that the marker data is also taken into\n consideration. void info ( Marker marker, String format, Object arg1, Object arg2) This method is similar to info(String, Object, Object) method except that the marker data is also taken into\n consideration. void info ( Marker marker, String msg, Throwable t) This method is similar to info(String, Throwable) method\n except that the marker data is also taken into consideration. boolean isDebugEnabled () Is the logger instance enabled for the DEBUG level? boolean isDebugEnabled ( Marker marker) Similar to isDebugEnabled() method except that the\n marker data is also taken into account. default boolean isEnabledForLevel ( Level level) Returns whether this Logger is enabled for a given Level . boolean isErrorEnabled () Is the logger instance enabled for the ERROR level? boolean isErrorEnabled ( Marker marker) Similar to isErrorEnabled() method except that the\n marker data is also taken into consideration. boolean isInfoEnabled () Is the logger instance enabled for the INFO level? boolean isInfoEnabled ( Marker marker) Similar to isInfoEnabled() method except that the marker\n data is also taken into consideration. boolean isTraceEnabled () Is the logger instance enabled for the TRACE level? boolean isTraceEnabled ( Marker marker) Similar to isTraceEnabled() method except that the\n marker data is also taken into account. boolean isWarnEnabled () Is the logger instance enabled for the WARN level? boolean isWarnEnabled ( Marker marker) Similar to isWarnEnabled() method except that the marker\n data is also taken into consideration. default LoggingEventBuilder makeLoggingEventBuilder ( Level level) Make a new LoggingEventBuilder instance as appropriate for this logger implementation. void trace ( String msg) Log a message at the TRACE level. void trace ( String format, Object arg) Log a message at the TRACE level according to the specified format\n and argument. void trace ( String format, Object ...\u00a0arguments) Log a message at the TRACE level according to the specified format\n and arguments. void trace ( String format, Object arg1, Object arg2) Log a message at the TRACE level according to the specified format\n and arguments. void trace ( String msg, Throwable t) Log an exception (throwable) at the TRACE level with an\n accompanying message. void trace ( Marker marker, String msg) Log a message with the specific Marker at the TRACE level. void trace ( Marker marker, String format, Object arg) This method is similar to trace(String, Object) method except that the\n marker data is also taken into consideration. void trace ( Marker marker, String format, Object ...\u00a0argArray) This method is similar to trace(String, Object...) method except that the marker data is also taken into\n consideration. void trace ( Marker marker, String format, Object arg1, Object arg2) This method is similar to trace(String, Object, Object) method except that the marker data is also taken into\n consideration. void trace ( Marker marker, String msg, Throwable t) This method is similar to trace(String, Throwable) method except that the\n marker data is also taken into consideration. void warn ( String msg) Log a message at the WARN level. void warn ( String format, Object arg) Log a message at the WARN level according to the specified format\n and argument. void warn ( String format, Object ...\u00a0arguments) Log a message at the WARN level according to the specified format\n and arguments. void warn ( String format, Object arg1, Object arg2) Log a message at the WARN level according to the specified format\n and arguments. void warn ( String msg, Throwable t) Log an exception (throwable) at the WARN level with an\n accompanying message. void warn ( Marker marker, String msg) Log a message with the specific Marker at the WARN level. void warn ( Marker marker, String format, Object arg) This method is similar to warn(String, Object) method except that the\n marker data is also taken into consideration. void warn ( Marker marker, String format, Object ...\u00a0arguments) This method is similar to warn(String, Object...) method except that the marker data is also taken into\n consideration. void warn ( Marker marker, String format, Object arg1, Object arg2) This method is similar to warn(String, Object, Object) method except that the marker data is also taken into\n consideration. void warn ( Marker marker, String msg, Throwable t) This method is similar to warn(String, Throwable) method\n except that the marker data is also taken into consideration. Field Details ROOT_LOGGER_NAME static final String ROOT_LOGGER_NAME Case-insensitive String constant used to retrieve the name of the root logger. Since:",
        "org.slf4j.LoggerFactory": "LoggerFactory (SLF4J javadoc) JavaScript is disabled on your browser. Skip navigation links Overview Package Class Use Tree Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field | Constr\u00a0| Method Detail: Field | Constr\u00a0| Method SEARCH Package org.slf4j Class LoggerFactory java.lang.Object org.slf4j.LoggerFactory public final class LoggerFactory extends Object The LoggerFactory is a utility class producing Loggers for\n various logging APIs, e.g. logback, reload4j, log4j and JDK 1.4 logging.\n Other implementations such as NOPLogger and\n SimpleLogger are also supported. LoggerFactory is essentially a wrapper around an ILoggerFactory instance provided by a SLF4JServiceProvider . Please note that all methods in LoggerFactory are static. Author: Alexander Dorokhine, Robert Elliot, Ceki G\u00fclc\u00fc Field Summary Fields Modifier and Type Field Description static final String PROVIDER_PROPERTY_KEY System property for explicitly setting the provider class. Method Summary All Methods Static Methods Concrete Methods Modifier and Type Method Description static ILoggerFactory getILoggerFactory () Return the ILoggerFactory instance in use. static Logger getLogger ( Class <?>\u00a0clazz) Return a logger named corresponding to the class passed as parameter,\n using the statically bound ILoggerFactory instance. static Logger getLogger ( String name) Return a logger named according to the name parameter using the\n statically bound ILoggerFactory instance. Methods inherited from class\u00a0java.lang. Object clone , equals , finalize , getClass , hashCode , notify , notifyAll , toString , wait , wait , wait Field Details PROVIDER_PROPERTY_KEY public static final String PROVIDER_PROPERTY_KEY System property for explicitly setting the provider class. If set and the provider could be instantiated,\n then the service loading mechanism will be bypassed. Since:",
        "java.io.IOException": "IOException (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr | Method Detail: Field\u00a0| Constr | Method SEARCH Module java.base Package java.io Class IOException java.lang.Object java.lang.Throwable java.lang.Exception java.io.IOException All Implemented Interfaces: Serializable Direct Known Subclasses: AttachOperationFailedException , ChangedCharSetException , CharacterCodingException , CharConversionException , ClosedChannelException , ClosedConnectionException , EOFException , FileLockInterruptionException , FileNotFoundException , FilerException , FileSystemException , HttpRetryException , HttpTimeoutException , IIOException , InterruptedByTimeoutException , InterruptedIOException , InvalidPropertiesFormatException , JMXProviderException , JMXServerErrorException , MalformedURLException , ObjectStreamException , ProtocolException , RemoteException , SaslException , SocketException , SSLException , SyncFailedException , TransportTimeoutException , UnknownHostException , UnknownServiceException , UnsupportedEncodingException , UserPrincipalNotFoundException , UTFDataFormatException , WebSocketHandshakeException , ZipException public class IOException extends Exception Signals that an I/O exception of some sort has occurred. This\n class is the general class of exceptions produced by failed or\n interrupted I/O operations. Since:",
        "java.nio.file.Path": "Path (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr\u00a0| Method Detail: Field\u00a0| Constr\u00a0| Method SEARCH Module java.base Package java.nio.file Interface Path All Superinterfaces: Comparable < Path > , Iterable < Path > , Watchable public interface Path extends Comparable < Path >, Iterable < Path >, Watchable An object that may be used to locate a file in a file system. It will\n typically represent a system dependent file path. A Path represents a path that is hierarchical and composed of a\n sequence of directory and file name elements separated by a special separator\n or delimiter. A root component , that identifies a file system\n hierarchy, may also be present. The name element that is farthest from the root of the directory hierarchy is the name of a file or directory.\n The other name elements are directory names. A Path can represent a\n root, a root and a sequence of names, or simply one or more name elements.\n A Path is considered to be an empty path if it consists\n solely of one name element that is empty. Accessing a file using an empty path is equivalent to accessing the default directory of the\n file system. Path defines the getFileName , getParent , getRoot , and subpath methods to access the path components or a subsequence of its name\n elements. In addition to accessing the components of a path, a Path also\n defines the resolve and resolveSibling methods to combine paths. The relativize method that can be used to construct a relative path between two paths.\n Paths can be compared , and tested against each other using\n the startsWith and endsWith methods. This interface extends Watchable interface so that a directory\n located by a path can be registered with a WatchService and entries in the directory watched. WARNING: This interface is only intended to be implemented by\n those developing custom file system implementations. Methods may be added to\n this interface in future releases. Accessing Files Paths may be used with the Files class to operate on files,\n directories, and other types of files. For example, suppose we want a BufferedReader to read text from a file \" access.log \". The\n file is located in a directory \" logs \" relative to the current working\n directory and is UTF-8 encoded. Copy Path path = FileSystems.getDefault().getPath(\"logs\", \"access.log\");\n    BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8); Interoperability Paths associated with the default provider are generally interoperable\n with the java.io.File class. Paths created by other\n providers are unlikely to be interoperable with the abstract path names\n represented by java.io.File . The toPath method may be used to obtain a Path from the abstract path name\n represented by a java.io.File object. The resulting Path can\n be used to operate on the same file as the java.io.File object. In\n addition, the toFile method is useful to construct a File from the String representation of a Path . Concurrency Implementations of this interface are immutable and safe for use by\n multiple concurrent threads. Since:",
        "java.util.List": "List (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr\u00a0| Method Detail: Field\u00a0| Constr\u00a0| Method SEARCH Module java.base Package java.util Interface List<E> Type Parameters: E - the type of elements in this list All Superinterfaces: Collection <E> , Iterable <E> , SequencedCollection <E> All Known Implementing Classes: AbstractList , AbstractSequentialList , ArrayList , AttributeList , CopyOnWriteArrayList , LinkedList , RoleList , RoleUnresolvedList , Stack , Vector public interface List<E> extends SequencedCollection <E> An ordered collection, where the user has precise control over where in the\n list each element is inserted.  The user can access elements by their integer\n index (position in the list), and search for elements in the list. Unlike sets, lists typically allow duplicate elements.  More formally,\n lists typically allow pairs of elements e1 and e2 such that e1.equals(e2) , and they typically allow multiple\n null elements if they allow null elements at all.  It is not inconceivable\n that someone might wish to implement a list that prohibits duplicates, by\n throwing runtime exceptions when the user attempts to insert them, but we\n expect this usage to be rare. The List interface places additional stipulations, beyond those\n specified in the Collection interface, on the contracts of the iterator , add , remove , equals , and hashCode methods.  Declarations for other inherited methods are\n also included here for convenience. The List interface provides four methods for positional (indexed)\n access to list elements.  Lists (like Java arrays) are zero based.  Note\n that these operations may execute in time proportional to the index value\n for some implementations (the LinkedList class, for\n example). Thus, iterating over the elements in a list is typically\n preferable to indexing through it if the caller does not know the\n implementation. The List interface provides a special iterator, called a ListIterator , that allows element insertion and replacement, and\n bidirectional access in addition to the normal operations that the Iterator interface provides.  A method is provided to obtain a\n list iterator that starts at a specified position in the list. The List interface provides two methods to search for a specified\n object.  From a performance standpoint, these methods should be used with\n caution.  In many implementations they will perform costly linear\n searches. The List interface provides two methods to efficiently insert and\n remove multiple elements at an arbitrary point in the list. Note: While it is permissible for lists to contain themselves as elements,\n extreme caution is advised: the equals and hashCode methods are no longer well defined on such a list. Some list implementations have restrictions on the elements that\n they may contain.  For example, some implementations prohibit null elements,\n and some have restrictions on the types of their elements.  Attempting to\n add an ineligible element throws an unchecked exception, typically NullPointerException or ClassCastException .  Attempting\n to query the presence of an ineligible element may throw an exception,\n or it may simply return false; some implementations will exhibit the former\n behavior and some will exhibit the latter.  More generally, attempting an\n operation on an ineligible element whose completion would not result in\n the insertion of an ineligible element into the list may throw an\n exception or it may succeed, at the option of the implementation.\n Such exceptions are marked as \"optional\" in the specification for this\n interface. Unmodifiable Lists The List.of and List.copyOf static factory methods\n provide a convenient way to create unmodifiable lists. The List instances created by these methods have the following characteristics: They are unmodifiable . Elements cannot\n be added, removed, or replaced. Calling any mutator method on the List\n will always cause UnsupportedOperationException to be thrown.\n However, if the contained elements are themselves mutable,\n this may cause the List's contents to appear to change. They disallow null elements. Attempts to create them with null elements result in NullPointerException . They are serializable if all elements are serializable. The order of elements in the list is the same as the order of the\n provided arguments, or of the elements in the provided array. The lists and their subList views implement the RandomAccess interface. They are value-based .\n Programmers should treat instances that are equal as interchangeable and should not use them for synchronization, or\n unpredictable behavior may occur. For example, in a future release,\n synchronization may fail. Callers should make no assumptions about the\n identity of the returned instances. Factories are free to\n create new instances or reuse existing ones. They are serialized as specified on the Serialized Form page. This interface is a member of the Java Collections Framework . Since:",
        "java.util.Optional": "Optional (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr\u00a0| Method Detail: Field\u00a0| Constr\u00a0| Method SEARCH Module java.base Package java.util Class Optional<T> java.lang.Object java.util.Optional<T> Type Parameters: T - the type of value public final class Optional<T> extends Object A container object which may or may not contain a non- null value.\n If a value is present, isPresent() returns true . If no\n value is present, the object is considered empty and isPresent() returns false . Additional methods that depend on the presence or absence of a contained\n value are provided, such as orElse() (returns a default value if no value is present) and ifPresent() (performs an\n action if a value is present). This is a value-based class; programmers should treat instances that are equal as interchangeable and should not\n use instances for synchronization, or unpredictable behavior may\n occur. For example, in a future release, synchronization may fail. API Note: Optional is primarily intended for use as a method return type where\n there is a clear need to represent \"no result,\" and where using null is likely to cause errors. A variable whose type is Optional should\n never itself be null ; it should always point to an Optional instance. Since:",
        "org.jabref.model.entry.field": null,
        "org.jabref.model.strings.StringUtil": null,
        "org.jabref.model.util.OptionalUtil": null,
        "java.util.*": null,
        "java.util.function.Predicate": "Predicate (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr\u00a0| Method Detail: Field\u00a0| Constr\u00a0| Method SEARCH Module java.base Package java.util.function Interface Predicate<T> Type Parameters: T - the type of the input to the predicate Functional Interface: This is a functional interface and can therefore be used as the assignment target for a lambda expression or method reference. @FunctionalInterface public interface Predicate<T> Represents a predicate (boolean-valued function) of one argument. This is a functional interface whose functional method is test(Object) . Since:",
        "java.util.stream.Collectors": "Collectors (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr\u00a0| Method Detail: Field\u00a0| Constr\u00a0| Method SEARCH Module java.base Package java.util.stream Class Collectors java.lang.Object java.util.stream.Collectors public final class Collectors extends Object Implementations of Collector that implement various useful reduction\n operations, such as accumulating elements into collections, summarizing\n elements according to various criteria, etc. The following are examples of using the predefined collectors to perform\n common mutable reduction tasks: // Accumulate names into a List\n List<String> list = people.stream()\n   .map(Person::getName)\n   .collect(Collectors.toList());\n\n // Accumulate names into a TreeSet\n Set<String> set = people.stream()\n   .map(Person::getName)\n   .collect(Collectors.toCollection(TreeSet::new));\n\n // Convert elements to strings and concatenate them, separated by commas\n String joined = things.stream()\n   .map(Object::toString)\n   .collect(Collectors.joining(\", \"));\n\n // Compute sum of salaries of employee\n int total = employees.stream()\n   .collect(Collectors.summingInt(Employee::getSalary));\n\n // Group employees by department\n Map<Department, List<Employee>> byDept = employees.stream()\n   .collect(Collectors.groupingBy(Employee::getDepartment));\n\n // Compute sum of salaries by department\n Map<Department, Integer> totalByDept = employees.stream()\n   .collect(Collectors.groupingBy(Employee::getDepartment,\n                                  Collectors.summingInt(Employee::getSalary)));\n\n // Partition students into passing and failing\n Map<Boolean, List<Student>> passingFailing = students.stream()\n   .collect(Collectors.partitioningBy(s -> s.getGrade() >= PASS_THRESHOLD)); Since:",
        "org.jabref.logic.texparser": null,
        "org.jabref.model.texparser.LatexParserResult": null,
        "org.junit.jupiter.api.Test": null,
        "java.net.URISyntaxException": "URISyntaxException (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr | Method Detail: Field\u00a0| Constr | Method SEARCH Module java.base Package java.net Class URISyntaxException java.lang.Object java.lang.Throwable java.lang.Exception java.net.URISyntaxException All Implemented Interfaces: Serializable public class URISyntaxException extends Exception Checked exception thrown to indicate that a string could not be parsed as a\n URI reference. Since:",
        "java.util.Arrays": "Arrays (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr\u00a0| Method Detail: Field\u00a0| Constr\u00a0| Method SEARCH Module java.base Package java.util Class Arrays java.lang.Object java.util.Arrays public final class Arrays extends Object This class contains various methods for manipulating arrays (such as\n sorting and searching). This class also contains a static factory\n that allows arrays to be viewed as lists. The methods in this class all throw a NullPointerException ,\n if the specified array reference is null, except where noted. The documentation for the methods contained in this class includes\n brief descriptions of the implementations . Such descriptions should\n be regarded as implementation notes , rather than parts of the specification . Implementors should feel free to substitute other\n algorithms, so long as the specification itself is adhered to. (For\n example, the algorithm used by sort(Object[]) does not have to be\n a MergeSort, but it does have to be stable .) This class is a member of the Java Collections Framework . Since:",
        "staticorg.junit.jupiter.api.Assertions.assertEquals": null,
        "org.jabref.logic.importer.fetcher": null,
        "kong.unirest.json.JSONArray": null,
        "kong.unirest.json.JSONException": null,
        "kong.unirest.json.JSONObject": null,
        "org.apache.http.client.utils.URIBuilder": null,
        "org.apache.lucene.queryparser.flexible.core.nodes.QueryNode": null,
        "org.jabref.logic.cleanup.FieldFormatterCleanup": null,
        "org.jabref.logic.formatter.bibtexfields.ClearFormatter": null,
        "org.jabref.logic.formatter.bibtexfields.RemoveBracesFormatter": null,
        "org.jabref.logic.importer.*": null,
        "org.jabref.logic.importer.fetcher.transformers.DefaultQueryTransformer": null,
        "org.jabref.logic.importer.util.JsonReader": null,
        "org.jabref.logic.util.strings.StringSimilarity": null,
        "org.jabref.model.entry.Author": null,
        "org.jabref.model.entry.AuthorList": null,
        "org.jabref.model.entry.field.StandardField": null,
        "org.jabref.model.entry.identifier.DOI": null,
        "org.jabref.model.entry.types.EntryType": null,
        "org.jabref.model.entry.types.StandardEntryType": null,
        "java.net.MalformedURLException": "MalformedURLException (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr | Method Detail: Field\u00a0| Constr | Method SEARCH Module java.base Package java.net Class MalformedURLException java.lang.Object java.lang.Throwable java.lang.Exception java.io.IOException java.net.MalformedURLException All Implemented Interfaces: Serializable public class MalformedURLException extends IOException Thrown to indicate that a malformed URL has occurred. Either no\n legal protocol could be found in a specification string or the\n string could not be parsed. Since:",
        "java.net.URL": "URL (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr | Method Detail: Field\u00a0| Constr | Method SEARCH Module java.base Package java.net Class URL java.lang.Object java.net.URL All Implemented Interfaces: Serializable public final class URL extends Object implements Serializable Class URL represents a Uniform Resource\n Locator, a pointer to a \"resource\" on the World\n Wide Web. A resource can be something as simple as a file or a\n directory, or it can be a reference to a more complicated object,\n such as a query to a database or to a search engine. More\n information on the types of URLs and their formats can be found at: Types of URL In general, a URL can be broken into several parts. Consider the\n following example: http://www.example.com/docs/resource1.html The URL above indicates that the protocol to use is http (HyperText Transfer Protocol) and that the\n information resides on a host machine named www.example.com . The information on that host\n machine is named /docs/resource1.html . The exact\n meaning of this name on the host machine is both protocol\n dependent and host dependent. The information normally resides in\n a file, but it could be generated on the fly. This component of\n the URL is called the path component. A URL can optionally specify a \"port\", which is the\n port number to which the TCP connection is made on the remote host\n machine. If the port is not specified, the default port for\n the protocol is used instead. For example, the default port for http is 80 . An alternative port could be\n specified as: http://www.example.com:1080/docs/resource1.html The syntax of URL is defined by RFC\u00a02396: Uniform\n Resource Identifiers (URI): Generic Syntax , amended by RFC\u00a02732: Format for\n Literal IPv6 Addresses in URLs . The Literal IPv6 address format\n also supports scope_ids. The syntax and usage of scope_ids is described here . A URL may have appended to it a \"fragment\", also known\n as a \"ref\" or a \"reference\". The fragment is indicated by the sharp\n sign character \"#\" followed by more characters. For example, http://www.example.com/index.html#chapter1 This fragment is not technically part of the URL. Rather, it\n indicates that after the specified resource is retrieved, the\n application is specifically interested in that part of the\n document that has the tag chapter1 attached to it. The\n meaning of a tag is resource specific. An application can also specify a \"relative URL\",\n which contains only enough information to reach the resource\n relative to another URL. Relative URLs are frequently used within\n HTML pages. For example, if the contents of the URL: http://www.example.com/index.html contained within it the relative URL: FAQ.html it would be a shorthand for: http://www.example.com/FAQ.html The relative URL need not specify all the components of a URL. If\n the protocol, host name, or port number is missing, the value is\n inherited from the fully specified URL. The file component must be\n specified. The optional fragment is not inherited. Constructing instances of URL The java.net.URL constructors are deprecated.\n Developers are encouraged to use java.net.URI to parse\n or construct a URL . In cases where an instance of java.net.URL is needed to open a connection, URI can be used\n to construct or parse the URL string, possibly calling URI.parseServerAuthority() to validate that the authority component\n can be parsed as a server-based authority, and then calling URI.toURL() to create the URL instance. The URL constructors are specified to throw MalformedURLException but the actual parsing/validation\n that is performed is implementation dependent. Some parsing/validation\n may be delayed until later, when the underlying stream handler's implementation is called.\n Being able to construct an instance of URL doesn't\n provide any guarantee about its conformance to the URL\n syntax specification. The URL class does not itself encode or decode any URL components\n according to the escaping mechanism defined in RFC2396. It is the\n responsibility of the caller to encode any fields, which need to be\n escaped prior to calling URL, and also to decode any escaped fields,\n that are returned from URL. Furthermore, because URL has no knowledge\n of URL escaping, it does not recognise equivalence between the encoded\n or decoded form of the same URL. For example, the two URLs: http://foo.com/hello world/ and http://foo.com/hello%20world would be considered not equal to each other. Note, the URI class does perform escaping of its\n component fields in certain circumstances. The recommended way\n to manage the encoding and decoding of URLs is to use URI ,\n and to convert between these two classes using toURI() and URI.toURL() . The URLEncoder and URLDecoder classes can also be\n used, but only for HTML form encoding, which is not the same\n as the encoding scheme defined in RFC2396. API Note: Applications working with file paths and file URIs should take great\n care to use the appropriate methods to convert between the two.\n The Path.of(URI) factory method and the File(URI) constructor can be used to create Path or File objects from a file URI. Path.toUri() and File.toURI() can be used to create a URI from a file path, which can be\n converted to URL using URI.toURL() .\n Applications should never try to construct or parse a URL from the direct string representation of a File or Path instance. Before constructing a URL from a URI , and depending\n on the protocol involved, applications should consider validating\n whether the URI authority can be parsed as server-based . Some components of a URL or URI, such as userinfo , may\n be abused to construct misleading URLs or URIs. Applications\n that deal with URLs or URIs should take into account\n the recommendations advised in RFC3986,\n Section 7, Security Considerations . All URL constructors may throw MalformedURLException .\n In particular, if the underlying URLStreamHandler implementation rejects, or is known to reject, any of the parameters, MalformedURLException may be thrown.\n Typically, a constructor that calls the stream handler's parseURL method may\n throw MalformedURLException if the underlying stream handler\n implementation of that method throws IllegalArgumentException .\n However, which checks are performed, or not, by the stream handlers\n is implementation dependent, and callers should not rely on such\n checks for full URL validation. Since:",
        "java.util.ArrayList": "ArrayList (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field | Constr | Method Detail: Field\u00a0| Constr | Method SEARCH Module java.base Package java.util Class ArrayList<E> java.lang.Object java.util.AbstractCollection <E> java.util.AbstractList <E> java.util.ArrayList<E> Type Parameters: E - the type of elements in this list All Implemented Interfaces: Serializable , Cloneable , Iterable <E> , Collection <E> , List <E> , RandomAccess , SequencedCollection <E> Direct Known Subclasses: AttributeList , RoleList , RoleUnresolvedList public class ArrayList<E> extends AbstractList <E>\nimplements List <E>, RandomAccess , Cloneable , Serializable Resizable-array implementation of the List interface.  Implements\n all optional list operations, and permits all elements, including null .  In addition to implementing the List interface,\n this class provides methods to manipulate the size of the array that is\n used internally to store the list.  (This class is roughly equivalent to Vector , except that it is unsynchronized.) The size , isEmpty , get , set , iterator , and listIterator operations run in constant\n time.  The add operation runs in amortized constant time ,\n that is, adding n elements requires O(n) time.  All of the other operations\n run in linear time (roughly speaking).  The constant factor is low compared\n to that for the LinkedList implementation. Each ArrayList instance has a capacity .  The capacity is\n the size of the array used to store the elements in the list.  It is always\n at least as large as the list size.  As elements are added to an ArrayList,\n its capacity grows automatically.  The details of the growth policy are not\n specified beyond the fact that adding an element has constant amortized\n time cost. An application can increase the capacity of an ArrayList instance\n before adding a large number of elements using the ensureCapacity operation.  This may reduce the amount of incremental reallocation. Note that this implementation is not synchronized. If multiple threads access an ArrayList instance concurrently,\n and at least one of the threads modifies the list structurally, it must be synchronized externally.  (A structural modification is\n any operation that adds or deletes one or more elements, or explicitly\n resizes the backing array; merely setting the value of an element is not\n a structural modification.)  This is typically accomplished by\n synchronizing on some object that naturally encapsulates the list.\n\n If no such object exists, the list should be \"wrapped\" using the Collections.synchronizedList method.  This is best done at creation time, to prevent accidental\n unsynchronized access to the list: List list = Collections.synchronizedList(new ArrayList(...)); The iterators returned by this class's iterator and listIterator methods are fail-fast :\n if the list is structurally modified at any time after the iterator is\n created, in any way except through the iterator's own remove or add methods, the iterator will throw a ConcurrentModificationException .  Thus, in the face of\n concurrent modification, the iterator fails quickly and cleanly, rather\n than risking arbitrary, non-deterministic behavior at an undetermined\n time in the future. Note that the fail-fast behavior of an iterator cannot be guaranteed\n as it is, generally speaking, impossible to make any hard guarantees in the\n presence of unsynchronized concurrent modification.  Fail-fast iterators\n throw ConcurrentModificationException on a best-effort basis.\n Therefore, it would be wrong to write a program that depended on this\n exception for its correctness: the fail-fast behavior of iterators\n should be used only to detect bugs. This class is a member of the Java Collections Framework . Since:",
        "java.util.Collections": "Collections (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field | Constr\u00a0| Method Detail: Field | Constr\u00a0| Method SEARCH Module java.base Package java.util Class Collections java.lang.Object java.util.Collections public class Collections extends Object This class consists exclusively of static methods that operate on or return\n collections.  It contains polymorphic algorithms that operate on\n collections, \"wrappers\", which return a new collection backed by a\n specified collection, and a few other odds and ends. The methods of this class all throw a NullPointerException if the collections or class objects provided to them are null. The documentation for the polymorphic algorithms contained in this class\n generally includes a brief description of the implementation .  Such\n descriptions should be regarded as implementation notes , rather than\n parts of the specification .  Implementors should feel free to\n substitute other algorithms, so long as the specification itself is adhered\n to.  (For example, the algorithm used by sort does not have to be\n a mergesort, but it does have to be stable .) The \"destructive\" algorithms contained in this class, that is, the\n algorithms that modify the collection on which they operate, are specified\n to throw UnsupportedOperationException if the collection does not\n support the appropriate mutation primitive(s), such as the set method.  These algorithms may, but are not required to, throw this\n exception if an invocation would have no effect on the collection.  For\n example, invoking the sort method on an unmodifiable list that is\n already sorted may or may not throw UnsupportedOperationException . This class is a member of the Java Collections Framework . Since:",
        "java.util.stream.IntStream": "IntStream (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested | Field\u00a0| Constr\u00a0| Method Detail: Field\u00a0| Constr\u00a0| Method SEARCH Module java.base Package java.util.stream Interface IntStream All Superinterfaces: AutoCloseable , BaseStream < Integer , IntStream > public interface IntStream extends BaseStream < Integer , IntStream > A sequence of primitive int-valued elements supporting sequential and parallel\n aggregate operations.  This is the int primitive specialization of Stream . The following example illustrates an aggregate operation using Stream and IntStream , computing the sum of the weights of the\n red widgets: int sum = widgets.stream()\n                      .filter(w -> w.getColor() == RED)\n                      .mapToInt(w -> w.getWeight())\n                      .sum(); See the class documentation for Stream and the package documentation\n for java.util.stream for additional\n specification of streams, stream operations, stream pipelines, and\n parallelism. Since:",
        "org.jabref.gui": null,
        "java.awt.Toolkit": "Toolkit (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field | Constr | Method Detail: Field | Constr | Method SEARCH Module java.desktop Package java.awt Class Toolkit java.lang.Object java.awt.Toolkit public abstract class Toolkit extends Object This class is the abstract superclass of all actual\n implementations of the Abstract Window Toolkit. Subclasses of\n the Toolkit class are used to bind the various components\n to particular native toolkit implementations. Many GUI events may be delivered to user\n asynchronously, if the opposite is not specified explicitly.\n As well as\n many GUI operations may be performed asynchronously.\n This fact means that if the state of a component is set, and then\n the state immediately queried, the returned value may not yet\n reflect the requested change.  This behavior includes, but is not\n limited to: Scrolling to a specified position. For example, calling ScrollPane.setScrollPosition and then getScrollPosition may return an incorrect\n     value if the original request has not yet been processed. Moving the focus from one component to another. For more information, see Timing\n Focus Transfers , a section in The Swing\n Tutorial . Making a top-level container visible. Calling setVisible(true) on a Window , Frame or Dialog may occur\n     asynchronously. Setting the size or location of a top-level container. Calls to setSize , setBounds or setLocation on a Window , Frame or Dialog are forwarded\n     to the underlying window management system and may be\n     ignored or modified.  See Window for\n     more information. Most applications should not call any of the methods in this\n class directly. The methods defined by Toolkit are\n the \"glue\" that joins the platform-independent classes in the java.awt package with their counterparts in java.awt.peer . Some methods defined by Toolkit query the native operating system directly. Since:",
        "java.awt.datatransfer.DataFlavor": "DataFlavor (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field | Constr | Method Detail: Field | Constr | Method SEARCH Module java.datatransfer Package java.awt.datatransfer Class DataFlavor java.lang.Object java.awt.datatransfer.DataFlavor All Implemented Interfaces: Externalizable , Serializable , Cloneable public class DataFlavor extends Object implements Externalizable , Cloneable A DataFlavor provides meta information about data. DataFlavor is typically used to access data on the clipboard, or during a drag and drop\n operation. An instance of DataFlavor encapsulates a content type as defined in RFC 2045 and RFC 2046 . A content type is\n typically referred to as a MIME type. A content type consists of a media type (referred to as the primary type), a\n subtype, and optional parameters. See RFC 2045 for details on the\n syntax of a MIME type. The JRE data transfer implementation interprets the parameter\n \"class\" of a MIME type as a representation class . The\n representation class reflects the class of the object being transferred. In\n other words, the representation class is the type of object returned by Transferable.getTransferData(java.awt.datatransfer.DataFlavor) . For example, the MIME type of imageFlavor is \"image/x-java-image;class=java.awt.Image\" ,\n the primary type is image , the subtype is x-java-image , and\n the representation class is java.awt.Image . When getTransferData is invoked with a DataFlavor of imageFlavor , an instance of java.awt.Image is returned. It's\n important to note that DataFlavor does no error checking against the\n representation class. It is up to consumers of DataFlavor , such as Transferable , to honor the representation class. Note, if you do not specify a representation class when creating a DataFlavor , the default representation class is used. See appropriate\n documentation for DataFlavor 's constructors. Also, DataFlavor instances with the \"text\" primary MIME\n type may have a \"charset\" parameter. Refer to RFC 2046 and selectBestTextFlavor(java.awt.datatransfer.DataFlavor[]) for details on \"text\" MIME types and\n the \"charset\" parameter. Equality of DataFlavors is determined by the primary type, subtype,\n and representation class. Refer to equals(DataFlavor) for details.\n When determining equality, any optional parameters are ignored. For example,\n the following produces two DataFlavors that are considered identical: DataFlavor flavor1 = new DataFlavor(Object.class, \"X-test/test; class=<java.lang.Object>; foo=bar\");\n   DataFlavor flavor2 = new DataFlavor(Object.class, \"X-test/test; class=<java.lang.Object>; x=y\");\n   // The following returns true.\n   flavor1.equals(flavor2); As mentioned, flavor1 and flavor2 are considered identical.\n As such, asking a Transferable for either DataFlavor returns\n the same results. For more information on using data transfer with Swing see the How\n to Use Drag and Drop and Data Transfer , section in The Java Tutorial . Since:",
        "java.awt.datatransfer.StringSelection": "StringSelection (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr | Method Detail: Field\u00a0| Constr | Method SEARCH Module java.datatransfer Package java.awt.datatransfer Class StringSelection java.lang.Object java.awt.datatransfer.StringSelection All Implemented Interfaces: ClipboardOwner , Transferable public class StringSelection extends Object implements Transferable , ClipboardOwner A Transferable which implements the capability required to transfer a String . This Transferable properly supports DataFlavor.stringFlavor and all equivalent flavors. Support for DataFlavor.plainTextFlavor and all equivalent flavors is deprecated . No other DataFlavor s\n are supported. Since:",
        "java.awt.datatransfer.Transferable": "Transferable (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr\u00a0| Method Detail: Field\u00a0| Constr\u00a0| Method SEARCH Module java.datatransfer Package java.awt.datatransfer Interface Transferable All Known Implementing Classes: DropTargetContext.TransferableProxy , StringSelection public interface Transferable Defines the interface for classes that can be used to provide data for a\n transfer operation. For information on using data transfer with Swing, see How to Use Drag and Drop and Data Transfer , a section in The Java Tutorial , for more information. Since:",
        "java.awt.datatransfer.UnsupportedFlavorException": "UnsupportedFlavorException (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr | Method Detail: Field\u00a0| Constr | Method SEARCH Module java.datatransfer Package java.awt.datatransfer Class UnsupportedFlavorException java.lang.Object java.lang.Throwable java.lang.Exception java.awt.datatransfer.UnsupportedFlavorException All Implemented Interfaces: Serializable public class UnsupportedFlavorException extends Exception Signals that the requested data is not supported in this flavor. Since:",
        "javafx.application.Platform": "Platform (JavaFX 21) JavaScript is disabled on your browser. Skip navigation links JavaFX\u00a021 Overview Module Package Class Use Tree New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr\u00a0| Method Detail: Field\u00a0| Constr\u00a0| Method SEARCH Module javafx.graphics Package javafx.application Class Platform java.lang.Object javafx.application.Platform public final class Platform extends Object Application platform support class. Since:",
        "javafx.scene.control.TextInputControl": "TextInputControl (JavaFX 21) JavaScript is disabled on your browser. Skip navigation links JavaFX\u00a021 Overview Module Package Class Use Tree New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested | Field | Constr | Method Detail: Field\u00a0| Constr | Method SEARCH Module javafx.controls Package javafx.scene.control Class TextInputControl java.lang.Object javafx.scene.Node javafx.scene.Parent javafx.scene.layout.Region javafx.scene.control.Control javafx.scene.control.TextInputControl All Implemented Interfaces: Styleable , EventTarget , Skinnable Direct Known Subclasses: TextArea , TextField @DefaultProperty (\"text\") public abstract class TextInputControl extends Control Abstract base class for text input controls. Since:",
        "javafx.scene.input.Clipboard": "Clipboard (JavaFX 21) JavaScript is disabled on your browser. Skip navigation links JavaFX\u00a021 Overview Module Package Class Use Tree New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr\u00a0| Method Detail: Field\u00a0| Constr\u00a0| Method SEARCH Module javafx.graphics Package javafx.scene.input Class Clipboard java.lang.Object javafx.scene.input.Clipboard Direct Known Subclasses: Dragboard public class Clipboard extends Object Represents an operating system clipboard, on which data may be placed during, for\n example, cut, copy, and paste operations. To access the general system clipboard, use the following code: Clipboard clipboard = Clipboard.getSystemClipboard(); There is only ever one instance of the system clipboard in the application, so it is\n perfectly acceptable to stash a reference to it somewhere handy if you so choose. The Clipboard operates on the concept of having a single conceptual item on the\n clipboard at any one time -- though it may be placed on the clipboard in different\n formats. For example, the user might select text in an HTML editor and press the\n ctrl+c or cmd+c to copy it. In this case, the same text might be available on the\n clipboard both as HTML and as plain text. There are two copies of the data on the\n clipboard, but they both represent the same data. Content is specified on the Clipboard by using the setContent(java.util.Map<javafx.scene.input.DataFormat, java.lang.Object>) method. First, construct a ClipboardContent object, then invoke setContent. Every time\n setContent is called, any previous data on the clipboard is cleared and replaced with\n this new content. final Clipboard clipboard = Clipboard.getSystemClipboard();\n     final ClipboardContent content = new ClipboardContent();\n     content.putString(\"Some text\");\n     content.putHtml(\"<b>Some</b> text\");\n     clipboard.setContent(content); The ClipboardContent class is simply a map with convenience methods for dealing\n with common data types added to a clipboard. Because multiple representations of the same data may exist on the clipboard, and because\n different applications have different capabilities for handling different content types,\n it is important to place as many data representations on the clipboard as is practical to\n facilitate external applications. Note that sometimes the operating system might be\n helpful in some cases and add multiple types for you. For example, the Mac might set the\n plain text string for you when you specify the RTF type. How and under what circumstances\n this occurs is outside the realm of this specification, consult your OS documentation. When reading data off the clipboard, it is important to look for the richest\n supported type first. For example, if I have a text document which supports embedding of\n images and media formats, when pasting content from the clipboard I should first check to\n see if the content can be represented as media or as an image. If not, then I might check\n for RTF or HTML or whatever rich text format is supported by my document type. If not,\n then I might just take a String. Or for example, if I have a plain text document, then I would simple get a String\n representation and use that, if available. I can check to see if the clipboard \"hasHtml\"\n or \"hasString\". if (clipboard.hasString()) { ... } In addition to the common or built in types, you may put any arbitrary data onto the\n clipboard (assuming it is serializable). Content types are defined by the DataFormat objects.\n The DataFormat class defines an immutable object, and there are a number of static final\n fields for common DataFormat types. Of course application specific DataFormat types can also be\n declared and used. The following two methods are equivalent (and the second call\n will override the first!) ClipboardContent content = new ClipboardContent();\n     content.putString(\"some text\");\n     content.put(DataFormat.PLAIN_TEXT, \"other text\"); On embedded platforms that do not have their own windowing system, the\n Clipboard returned from Clipboard.getSystemClipboard() might not be\n accessible from outside the JavaFX application. If a security manager is present, the application must have the FXPermission \"accessClipboard\" in order for the\n Clipboard returned from Clipboard.getSystemClipboard() to be\n accessible from outside the JavaFX application. For compatibility with\n previous versions of the JDK the equivalent AWTPermission \"accessClipboard\" will also allow the FX clipboard to be accessible from\n outside the JavaFX application. If the application lacks permission or if the platform doesn't support\n a shared clipboard, the clipboard\n returned by Clipboard.getSystemClipboard() can be used for exchange of data\n between different parts of one JavaFX application but cannot be used to\n exchange data between multiple applications. Since:",
        "javafx.scene.input.ClipboardContent": "ClipboardContent (JavaFX 21) JavaScript is disabled on your browser. Skip navigation links JavaFX\u00a021 Overview Module Package Class Use Tree New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested | Field\u00a0| Constr | Method Detail: Field\u00a0| Constr | Method SEARCH Module javafx.graphics Package javafx.scene.input Class ClipboardContent java.lang.Object java.util.AbstractMap <K, V> java.util.HashMap < DataFormat , Object > javafx.scene.input.ClipboardContent All Implemented Interfaces: Serializable , Cloneable , Map < DataFormat , Object > public class ClipboardContent extends HashMap < DataFormat , Object > Data container for Clipboard data. It can hold multiple data in\n several data formats. Since:",
        "javafx.scene.input.DataFormat": "DataFormat (JavaFX 21) JavaScript is disabled on your browser. Skip navigation links JavaFX\u00a021 Overview Module Package Class Use Tree New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field | Constr | Method Detail: Field | Constr | Method SEARCH Module javafx.graphics Package javafx.scene.input Class DataFormat java.lang.Object javafx.scene.input.DataFormat public class DataFormat extends Object Data format identifier used as means\n of identifying the data stored on a clipboard/dragboard. Since:",
        "javafx.scene.input.MouseButton": "MouseButton (JavaFX 21) JavaScript is disabled on your browser. Skip navigation links JavaFX\u00a021 Overview Module Package Class Use Tree New Deprecated Index Help Summary: Nested Enum Constants Field Method Detail: Enum Constants Field Method Summary: Nested | Enum Constants | Field\u00a0| Method Detail: Enum Constants | Field\u00a0| Method SEARCH Module javafx.graphics Package javafx.scene.input Enum Class MouseButton java.lang.Object java.lang.Enum < MouseButton > javafx.scene.input.MouseButton All Implemented Interfaces: Serializable , Comparable < MouseButton > , Constable public enum MouseButton extends Enum < MouseButton > Mapping for Button Names Since:",
        "org.jabref.architecture.AllowedToUseAwt": null,
        "org.jabref.logic.bibtex.BibEntryWriter": null,
        "org.jabref.logic.bibtex.FieldWriter": null,
        "org.jabref.model.database.BibDatabaseMode": null,
        "org.jabref.preferences.PreferencesService": null,
        "org.jabref.logic.autosaveandbackup": null,
        "java.util.HashSet": "HashSet (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr | Method Detail: Field\u00a0| Constr | Method SEARCH Module java.base Package java.util Class HashSet<E> java.lang.Object java.util.AbstractCollection <E> java.util.AbstractSet <E> java.util.HashSet<E> Type Parameters: E - the type of elements maintained by this set All Implemented Interfaces: Serializable , Cloneable , Iterable <E> , Collection <E> , Set <E> Direct Known Subclasses: JobStateReasons , LinkedHashSet public class HashSet<E> extends AbstractSet <E>\nimplements Set <E>, Cloneable , Serializable This class implements the Set interface, backed by a hash table\n (actually a HashMap instance).  It makes no guarantees as to the\n iteration order of the set; in particular, it does not guarantee that the\n order will remain constant over time.  This class permits the null element. This class offers constant time performance for the basic operations\n ( add , remove , contains and size ),\n assuming the hash function disperses the elements properly among the\n buckets.  Iterating over this set requires time proportional to the sum of\n the HashSet instance's size (the number of elements) plus the\n \"capacity\" of the backing HashMap instance (the number of\n buckets).  Thus, it's very important not to set the initial capacity too\n high (or the load factor too low) if iteration performance is important. Note that this implementation is not synchronized. If multiple threads access a hash set concurrently, and at least one of\n the threads modifies the set, it must be synchronized externally.\n This is typically accomplished by synchronizing on some object that\n naturally encapsulates the set.\n\n If no such object exists, the set should be \"wrapped\" using the Collections.synchronizedSet method.  This is best done at creation time, to prevent accidental\n unsynchronized access to the set: Set s = Collections.synchronizedSet(new HashSet(...)); The iterators returned by this class's iterator method are fail-fast : if the set is modified at any time after the iterator is\n created, in any way except through the iterator's own remove method, the Iterator throws a ConcurrentModificationException .\n Thus, in the face of concurrent modification, the iterator fails quickly\n and cleanly, rather than risking arbitrary, non-deterministic behavior at\n an undetermined time in the future. Note that the fail-fast behavior of an iterator cannot be guaranteed\n as it is, generally speaking, impossible to make any hard guarantees in the\n presence of unsynchronized concurrent modification.  Fail-fast iterators\n throw ConcurrentModificationException on a best-effort basis.\n Therefore, it would be wrong to write a program that depended on this\n exception for its correctness: the fail-fast behavior of iterators\n should be used only to detect bugs. This class is a member of the Java Collections Framework . Since:",
        "java.util.Set": "Set (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr\u00a0| Method Detail: Field\u00a0| Constr\u00a0| Method SEARCH Module java.base Package java.util Interface Set<E> Type Parameters: E - the type of elements maintained by this set All Superinterfaces: Collection <E> , Iterable <E> All Known Subinterfaces: EventSet , NavigableSet <E> , SequencedSet <E> , SortedSet <E> All Known Implementing Classes: AbstractSet , ConcurrentHashMap.KeySetView , ConcurrentSkipListSet , CopyOnWriteArraySet , EnumSet , HashSet , JobStateReasons , LinkedHashSet , TreeSet public interface Set<E> extends Collection <E> A collection that contains no duplicate elements.  More formally, sets\n contain no pair of elements e1 and e2 such that e1.equals(e2) , and at most one null element.  As implied by\n its name, this interface models the mathematical set abstraction. The Set interface places additional stipulations, beyond those\n inherited from the Collection interface, on the contracts of all\n constructors and on the contracts of the add , equals and hashCode methods.  Declarations for other inherited methods are\n also included here for convenience.  (The specifications accompanying these\n declarations have been tailored to the Set interface, but they do\n not contain any additional stipulations.) The additional stipulation on constructors is, not surprisingly,\n that all constructors must create a set that contains no duplicate elements\n (as defined above). Note: Great care must be exercised if mutable objects are used as set\n elements.  The behavior of a set is not specified if the value of an object\n is changed in a manner that affects equals comparisons while the\n object is an element in the set.  A special case of this prohibition is\n that it is not permissible for a set to contain itself as an element. Some set implementations have restrictions on the elements that\n they may contain.  For example, some implementations prohibit null elements,\n and some have restrictions on the types of their elements.  Attempting to\n add an ineligible element throws an unchecked exception, typically NullPointerException or ClassCastException .  Attempting\n to query the presence of an ineligible element may throw an exception,\n or it may simply return false; some implementations will exhibit the former\n behavior and some will exhibit the latter.  More generally, attempting an\n operation on an ineligible element whose completion would not result in\n the insertion of an ineligible element into the set may throw an\n exception or it may succeed, at the option of the implementation.\n Such exceptions are marked as \"optional\" in the specification for this\n interface. Unmodifiable Sets The Set.of and Set.copyOf static factory methods\n provide a convenient way to create unmodifiable sets. The Set instances created by these methods have the following characteristics: They are unmodifiable . Elements cannot\n be added or removed. Calling any mutator method on the Set\n will always cause UnsupportedOperationException to be thrown.\n However, if the contained elements are themselves mutable, this may cause the\n Set to behave inconsistently or its contents to appear to change. They disallow null elements. Attempts to create them with null elements result in NullPointerException . They are serializable if all elements are serializable. They reject duplicate elements at creation time. Duplicate elements\n passed to a static factory method result in IllegalArgumentException . The iteration order of set elements is unspecified and is subject to change. They are value-based .\n Programmers should treat instances that are equal as interchangeable and should not use them for synchronization, or\n unpredictable behavior may occur. For example, in a future release,\n synchronization may fail. Callers should make no assumptions\n about the identity of the returned instances. Factories are free to\n create new instances or reuse existing ones. They are serialized as specified on the Serialized Form page. This interface is a member of the Java Collections Framework . Since:",
        "java.util.concurrent.ArrayBlockingQueue": "ArrayBlockingQueue (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr | Method Detail: Field\u00a0| Constr | Method SEARCH Module java.base Package java.util.concurrent Class ArrayBlockingQueue<E> java.lang.Object java.util.AbstractCollection <E> java.util.AbstractQueue <E> java.util.concurrent.ArrayBlockingQueue<E> Type Parameters: E - the type of elements held in this queue All Implemented Interfaces: Serializable , Iterable <E> , Collection <E> , BlockingQueue <E> , Queue <E> public class ArrayBlockingQueue<E> extends AbstractQueue <E>\nimplements BlockingQueue <E>, Serializable A bounded blocking queue backed by an\n array.  This queue orders elements FIFO (first-in-first-out).  The head of the queue is that element that has been on the\n queue the longest time.  The tail of the queue is that\n element that has been on the queue the shortest time. New elements\n are inserted at the tail of the queue, and the queue retrieval\n operations obtain elements at the head of the queue. This is a classic \"bounded buffer\", in which a\n fixed-sized array holds elements inserted by producers and\n extracted by consumers.  Once created, the capacity cannot be\n changed.  Attempts to put an element into a full queue\n will result in the operation blocking; attempts to take an\n element from an empty queue will similarly block. This class supports an optional fairness policy for ordering\n waiting producer and consumer threads.  By default, this ordering\n is not guaranteed. However, a queue constructed with fairness set\n to true grants threads access in FIFO order. Fairness\n generally decreases throughput but reduces variability and avoids\n starvation. This class and its iterator implement all of the optional methods of the Collection and Iterator interfaces. This class is a member of the Java Collections Framework . Since:",
        "java.util.concurrent.BlockingQueue": "BlockingQueue (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr\u00a0| Method Detail: Field\u00a0| Constr\u00a0| Method SEARCH Module java.base Package java.util.concurrent Interface BlockingQueue<E> Type Parameters: E - the type of elements held in this queue All Superinterfaces: Collection <E> , Iterable <E> , Queue <E> All Known Subinterfaces: BlockingDeque <E> , TransferQueue <E> All Known Implementing Classes: ArrayBlockingQueue , DelayQueue , LinkedBlockingDeque , LinkedBlockingQueue , LinkedTransferQueue , PriorityBlockingQueue , SynchronousQueue public interface BlockingQueue<E> extends Queue <E> A Queue that additionally supports operations that wait for\n the queue to become non-empty when retrieving an element, and wait\n for space to become available in the queue when storing an element. BlockingQueue methods come in four forms, with different ways\n of handling operations that cannot be satisfied immediately, but may be\n satisfied at some point in the future:\n one throws an exception, the second returns a special value (either null or false , depending on the operation), the third\n blocks the current thread indefinitely until the operation can succeed,\n and the fourth blocks for only a given maximum time limit before giving\n up.  These methods are summarized in the following table: Summary of BlockingQueue methods Throws exception Special value Blocks Times out Insert add(e) offer(e) put(e) offer(e, time, unit) Remove remove() poll() take() poll(time, unit) Examine element() peek() not applicable not applicable A BlockingQueue does not accept null elements.\n Implementations throw NullPointerException on attempts\n to add , put or offer a null .  A null is used as a sentinel value to indicate failure of poll operations. A BlockingQueue may be capacity bounded. At any given\n time it may have a remainingCapacity beyond which no\n additional elements can be put without blocking.\n A BlockingQueue without any intrinsic capacity constraints always\n reports a remaining capacity of Integer.MAX_VALUE . BlockingQueue implementations are designed to be used\n primarily for producer-consumer queues, but additionally support\n the Collection interface.  So, for example, it is\n possible to remove an arbitrary element from a queue using remove(x) . However, such operations are in general not performed very efficiently, and are intended for only\n occasional use, such as when a queued message is cancelled. BlockingQueue implementations are thread-safe.  All\n queuing methods achieve their effects atomically using internal\n locks or other forms of concurrency control. However, the bulk Collection operations addAll , containsAll , retainAll and removeAll are not necessarily performed atomically unless specified\n otherwise in an implementation. So it is possible, for example, for addAll(c) to fail (throwing an exception) after adding\n only some of the elements in c . A BlockingQueue does not intrinsically support\n any kind of \"close\" or \"shutdown\" operation to\n indicate that no more items will be added.  The needs and usage of\n such features tend to be implementation-dependent. For example, a\n common tactic is for producers to insert special end-of-stream or poison objects, that are\n interpreted accordingly when taken by consumers. Usage example, based on a typical producer-consumer scenario.\n Note that a BlockingQueue can safely be used with multiple\n producers and multiple consumers. class Producer implements Runnable {\n   private final BlockingQueue queue;\n   Producer(BlockingQueue q) { queue = q; }\n   public void run() {\n     try {\n       while (true) { queue.put(produce()); }\n     } catch (InterruptedException ex) { ... handle ...}\n   }\n   Object produce() { ... }\n }\n\n class Consumer implements Runnable {\n   private final BlockingQueue queue;\n   Consumer(BlockingQueue q) { queue = q; }\n   public void run() {\n     try {\n       while (true) { consume(queue.take()); }\n     } catch (InterruptedException ex) { ... handle ...}\n   }\n   void consume(Object x) { ... }\n }\n\n class Setup {\n   void main() {\n     BlockingQueue q = new SomeQueueImplementation();\n     Producer p = new Producer(q);\n     Consumer c1 = new Consumer(q);\n     Consumer c2 = new Consumer(q);\n     new Thread(p).start();\n     new Thread(c1).start();\n     new Thread(c2).start();\n   }\n } Memory consistency effects: As with other concurrent\n collections, actions in a thread prior to placing an object into a BlockingQueue happen-before actions subsequent to the access or removal of that element from\n the BlockingQueue in another thread. This interface is a member of the Java Collections Framework . Since:",
        "java.util.concurrent.ExecutorService": "ExecutorService (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr\u00a0| Method Detail: Field\u00a0| Constr\u00a0| Method SEARCH Module java.base Package java.util.concurrent Interface ExecutorService All Superinterfaces: AutoCloseable , Executor All Known Subinterfaces: ScheduledExecutorService All Known Implementing Classes: AbstractExecutorService , ForkJoinPool , ScheduledThreadPoolExecutor , ThreadPoolExecutor public interface ExecutorService extends Executor , AutoCloseable An Executor that provides methods to manage termination and\n methods that can produce a Future for tracking progress of\n one or more asynchronous tasks. An ExecutorService can be shut down, which will cause\n it to reject new tasks.  Two different methods are provided for\n shutting down an ExecutorService . The shutdown() method will allow previously submitted tasks to execute before\n terminating, while the shutdownNow() method prevents waiting\n tasks from starting and attempts to stop currently executing tasks.\n Upon termination, an executor has no tasks actively executing, no\n tasks awaiting execution, and no new tasks can be submitted.  An\n unused ExecutorService should be shut down to allow\n reclamation of its resources. Method submit extends base method Executor.execute(Runnable) by creating and returning a Future that can be used to cancel execution and/or wait for completion.\n Methods invokeAny and invokeAll perform the most\n commonly useful forms of bulk execution, executing a collection of\n tasks and then waiting for at least one, or all, to\n complete. (Class ExecutorCompletionService can be used to\n write customized variants of these methods.) The Executors class provides factory methods for the\n executor services provided in this package. Usage Examples Here is a sketch of a network service in which threads in a thread\n pool service incoming requests. It uses the preconfigured Executors.newFixedThreadPool(int) factory method: class NetworkService implements Runnable {\n   private final ServerSocket serverSocket;\n   private final ExecutorService pool;\n\n   public NetworkService(int port, int poolSize)\n       throws IOException {\n     serverSocket = new ServerSocket(port);\n     pool = Executors.newFixedThreadPool(poolSize);\n   }\n\n   public void run() { // run the service\n     try {\n       for (;;) {\n         pool.execute(new Handler(serverSocket.accept()));\n       }\n     } catch (IOException ex) {\n       pool.shutdown();\n     }\n   }\n }\n\n class Handler implements Runnable {\n   private final Socket socket;\n   Handler(Socket socket) { this.socket = socket; }\n   public void run() {\n     // read and service request on socket\n   }\n } An ExecutorService may also be established and closed\n (shutdown, blocking until terminated) as follows; illustrating with\n a different Executors factory method: try (ExecutorService e =  Executors.newWorkStealingPool()) {\n   // submit or execute many tasks with e ...\n } Further customization is also possible. For example, the following\n method shuts down an ExecutorService in two phases, first\n by calling shutdown to reject incoming tasks, and then\n calling shutdownNow , if necessary, to cancel any lingering\n tasks: void shutdownAndAwaitTermination(ExecutorService pool) {\n   pool.shutdown(); // Disable new tasks from being submitted\n   try {\n     // Wait a while for existing tasks to terminate\n     if (!pool.awaitTermination(60, TimeUnit.SECONDS)) {\n       pool.shutdownNow(); // Cancel currently executing tasks\n       // Wait a while for tasks to respond to being cancelled\n       if (!pool.awaitTermination(60, TimeUnit.SECONDS))\n           System.err.println(\"Pool did not terminate\");\n     }\n   } catch (InterruptedException ex) {\n     // (Re-)Cancel if current thread also interrupted\n     pool.shutdownNow();\n     // Preserve interrupt status\n     Thread.currentThread().interrupt();\n   }\n } Memory consistency effects: Actions in a thread prior to the\n submission of a Runnable or Callable task to an ExecutorService happen-before any actions taken by that task, which in turn happen-before the\n result is retrieved via Future.get() . Since:",
        "java.util.concurrent.RejectedExecutionException": "RejectedExecutionException (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr | Method Detail: Field\u00a0| Constr | Method SEARCH Module java.base Package java.util.concurrent Class RejectedExecutionException java.lang.Object java.lang.Throwable java.lang.Exception java.lang.RuntimeException java.util.concurrent.RejectedExecutionException All Implemented Interfaces: Serializable public class RejectedExecutionException extends RuntimeException Exception thrown by an Executor when a task cannot be\n accepted for execution. Since:",
        "java.util.concurrent.ThreadPoolExecutor": "ThreadPoolExecutor (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested | Field\u00a0| Constr | Method Detail: Field\u00a0| Constr | Method SEARCH Module java.base Package java.util.concurrent Class ThreadPoolExecutor java.lang.Object java.util.concurrent.AbstractExecutorService java.util.concurrent.ThreadPoolExecutor All Implemented Interfaces: AutoCloseable , Executor , ExecutorService Direct Known Subclasses: ScheduledThreadPoolExecutor public class ThreadPoolExecutor extends AbstractExecutorService An ExecutorService that executes each submitted task using\n one of possibly several pooled threads, normally configured\n using Executors factory methods. Thread pools address two different problems: they usually\n provide improved performance when executing large numbers of\n asynchronous tasks, due to reduced per-task invocation overhead,\n and they provide a means of bounding and managing the resources,\n including threads, consumed when executing a collection of tasks.\n Each ThreadPoolExecutor also maintains some basic\n statistics, such as the number of completed tasks. To be useful across a wide range of contexts, this class\n provides many adjustable parameters and extensibility\n hooks. However, programmers are urged to use the more convenient Executors factory methods Executors.newCachedThreadPool() (unbounded thread pool, with\n automatic thread reclamation), Executors.newFixedThreadPool(int) (fixed size thread pool) and Executors.newSingleThreadExecutor() (single background thread), that\n preconfigure settings for the most common usage\n scenarios. Otherwise, use the following guide when manually\n configuring and tuning this class: Core and maximum pool sizes A ThreadPoolExecutor will automatically adjust the\n pool size (see getPoolSize() )\n according to the bounds set by\n corePoolSize (see getCorePoolSize() ) and\n maximumPoolSize (see getMaximumPoolSize() ).\n\n When a new task is submitted in method execute(Runnable) ,\n if fewer than corePoolSize threads are running, a new thread is\n created to handle the request, even if other worker threads are\n idle.  Else if fewer than maximumPoolSize threads are running, a\n new thread will be created to handle the request only if the queue\n is full.  By setting corePoolSize and maximumPoolSize the same, you\n create a fixed-size thread pool. By setting maximumPoolSize to an\n essentially unbounded value such as Integer.MAX_VALUE , you\n allow the pool to accommodate an arbitrary number of concurrent\n tasks. Most typically, core and maximum pool sizes are set only\n upon construction, but they may also be changed dynamically using setCorePoolSize(int) and setMaximumPoolSize(int) . On-demand construction By default, even core threads are initially created and\n started only when new tasks arrive, but this can be overridden\n dynamically using method prestartCoreThread() or prestartAllCoreThreads() .  You probably want to prestart threads if\n you construct the pool with a non-empty queue. Creating new threads New threads are created using a ThreadFactory .  If not\n otherwise specified, a Executors.defaultThreadFactory() is\n used, that creates threads to all be in the same ThreadGroup and with the same NORM_PRIORITY priority and\n non-daemon status. By supplying a different ThreadFactory, you can\n alter the thread's name, thread group, priority, daemon status,\n etc. If a ThreadFactory fails to create a thread when asked\n by returning null from newThread , the executor will\n continue, but might not be able to execute any tasks. Threads\n should possess the \"modifyThread\" RuntimePermission . If\n worker threads or other threads using the pool do not possess this\n permission, service may be degraded: configuration changes may not\n take effect in a timely manner, and a shutdown pool may remain in a\n state in which termination is possible but not completed. Keep-alive times If the pool currently has more than corePoolSize threads,\n excess threads will be terminated if they have been idle for more\n than the keepAliveTime (see getKeepAliveTime(TimeUnit) ).\n This provides a means of reducing resource consumption when the\n pool is not being actively used. If the pool becomes more active\n later, new threads will be constructed. This parameter can also be\n changed dynamically using method setKeepAliveTime(long, TimeUnit) .  Using a value of Long.MAX_VALUE TimeUnit.NANOSECONDS effectively disables idle threads from ever\n terminating prior to shut down. By default, the keep-alive policy\n applies only when there are more than corePoolSize threads, but\n method allowCoreThreadTimeOut(boolean) can be used to\n apply this time-out policy to core threads as well, so long as the\n keepAliveTime value is non-zero. Queuing Any BlockingQueue may be used to transfer and hold\n submitted tasks.  The use of this queue interacts with pool sizing: If fewer than corePoolSize threads are running, the Executor\n always prefers adding a new thread\n rather than queuing. If corePoolSize or more threads are running, the Executor\n always prefers queuing a request rather than adding a new\n thread. If a request cannot be queued, a new thread is created unless\n this would exceed maximumPoolSize, in which case, the task will be\n rejected. There are three general strategies for queuing: Direct handoffs. A good default choice for a work\n queue is a SynchronousQueue that hands off tasks to threads\n without otherwise holding them. Here, an attempt to queue a task\n will fail if no threads are immediately available to run it, so a\n new thread will be constructed. This policy avoids lockups when\n handling sets of requests that might have internal dependencies.\n Direct handoffs generally require unbounded maximumPoolSizes to\n avoid rejection of new submitted tasks. This in turn admits the\n possibility of unbounded thread growth when commands continue to\n arrive on average faster than they can be processed. Unbounded queues. Using an unbounded queue (for\n example a LinkedBlockingQueue without a predefined\n capacity) will cause new tasks to wait in the queue when all\n corePoolSize threads are busy. Thus, no more than corePoolSize\n threads will ever be created. (And the value of the maximumPoolSize\n therefore doesn't have any effect.)  This may be appropriate when\n each task is completely independent of others, so tasks cannot\n affect each others execution; for example, in a web page server.\n While this style of queuing can be useful in smoothing out\n transient bursts of requests, it admits the possibility of\n unbounded work queue growth when commands continue to arrive on\n average faster than they can be processed. Bounded queues. A bounded queue (for example, an ArrayBlockingQueue ) helps prevent resource exhaustion when\n used with finite maximumPoolSizes, but can be more difficult to\n tune and control.  Queue sizes and maximum pool sizes may be traded\n off for each other: Using large queues and small pools minimizes\n CPU usage, OS resources, and context-switching overhead, but can\n lead to artificially low throughput.  If tasks frequently block (for\n example if they are I/O bound), a system may be able to schedule\n time for more threads than you otherwise allow. Use of small queues\n generally requires larger pool sizes, which keeps CPUs busier but\n may encounter unacceptable scheduling overhead, which also\n decreases throughput. Rejected tasks New tasks submitted in method execute(Runnable) will be rejected when the Executor has been shut down, and also when\n the Executor uses finite bounds for both maximum threads and work queue\n capacity, and is saturated.  In either case, the execute method\n invokes the RejectedExecutionHandler.rejectedExecution(Runnable, ThreadPoolExecutor) method of its RejectedExecutionHandler .  Four predefined handler\n policies are provided: In the default ThreadPoolExecutor.AbortPolicy , the handler\n throws a runtime RejectedExecutionException upon rejection. In ThreadPoolExecutor.CallerRunsPolicy , the thread\n that invokes execute itself runs the task. This provides a\n simple feedback control mechanism that will slow down the rate that\n new tasks are submitted. In ThreadPoolExecutor.DiscardPolicy , a task that cannot\n be executed is simply dropped. This policy is designed only for\n those rare cases in which task completion is never relied upon. In ThreadPoolExecutor.DiscardOldestPolicy , if the\n executor is not shut down, the task at the head of the work queue\n is dropped, and then execution is retried (which can fail again,\n causing this to be repeated.) This policy is rarely acceptable.  In\n nearly all cases, you should also cancel the task to cause an\n exception in any component waiting for its completion, and/or log\n the failure, as illustrated in ThreadPoolExecutor.DiscardOldestPolicy documentation. It is possible to define and use other kinds of RejectedExecutionHandler classes. Doing so requires some care\n especially when policies are designed to work only under particular\n capacity or queuing policies. Hook methods This class provides protected overridable beforeExecute(Thread, Runnable) and afterExecute(Runnable, Throwable) methods that are called\n before and after execution of each task.  These can be used to\n manipulate the execution environment; for example, reinitializing\n ThreadLocals, gathering statistics, or adding log entries.\n Additionally, method terminated() can be overridden to perform\n any special processing that needs to be done once the Executor has\n fully terminated. If hook, callback, or BlockingQueue methods throw exceptions,\n internal worker threads may in turn fail, abruptly terminate, and\n possibly be replaced. Queue maintenance Method getQueue() allows access to the work queue\n for purposes of monitoring and debugging.  Use of this method for\n any other purpose is strongly discouraged.  Two supplied methods, remove(Runnable) and purge() are available to\n assist in storage reclamation when large numbers of queued tasks\n become cancelled. Reclamation A pool that is no longer referenced in a program AND has no remaining threads may be reclaimed (garbage collected)\n without being explicitly shutdown. You can configure a pool to\n allow all unused threads to eventually die by setting appropriate\n keep-alive times, using a lower bound of zero core threads and/or\n setting allowCoreThreadTimeOut(boolean) . Extension example. Most extensions of this class\n override one or more of the protected hook methods. For example,\n here is a subclass that adds a simple pause/resume feature: class PausableThreadPoolExecutor extends ThreadPoolExecutor {\n   private boolean isPaused;\n   private ReentrantLock pauseLock = new ReentrantLock();\n   private Condition unpaused = pauseLock.newCondition();\n\n   public PausableThreadPoolExecutor(...) { super(...); }\n\n   protected void beforeExecute(Thread t, Runnable r) {\n     super.beforeExecute(t, r);\n     pauseLock.lock();\n     try {\n       while (isPaused) unpaused.await();\n     } catch (InterruptedException ie) {\n       t.interrupt();\n     } finally {\n       pauseLock.unlock();\n     }\n   }\n\n   public void pause() {\n     pauseLock.lock();\n     try {\n       isPaused = true;\n     } finally {\n       pauseLock.unlock();\n     }\n   }\n\n   public void resume() {\n     pauseLock.lock();\n     try {\n       isPaused = false;\n       unpaused.signalAll();\n     } finally {\n       pauseLock.unlock();\n     }\n   }\n } Since:",
        "java.util.concurrent.TimeUnit": "TimeUnit (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Enum Constants Field Method Detail: Enum Constants Field Method Summary: Nested | Enum Constants | Field\u00a0| Method Detail: Enum Constants | Field\u00a0| Method SEARCH Module java.base Package java.util.concurrent Enum Class TimeUnit java.lang.Object java.lang.Enum < TimeUnit > java.util.concurrent.TimeUnit All Implemented Interfaces: Serializable , Comparable < TimeUnit > , Constable public enum TimeUnit extends Enum < TimeUnit > A TimeUnit represents time durations at a given unit of\n granularity and provides utility methods to convert across units,\n and to perform timing and delay operations in these units.  A TimeUnit does not maintain time information, but only\n helps organize and use time representations that may be maintained\n separately across various contexts.  A nanosecond is defined as one\n thousandth of a microsecond, a microsecond as one thousandth of a\n millisecond, a millisecond as one thousandth of a second, a minute\n as sixty seconds, an hour as sixty minutes, and a day as twenty four\n hours. A TimeUnit is mainly used to inform time-based methods\n how a given timing parameter should be interpreted. For example,\n the following code will timeout in 50 milliseconds if the lock is not available: Lock lock = ...;\n if (lock.tryLock(50L, TimeUnit.MILLISECONDS)) ... while this code will timeout in 50 seconds: Lock lock = ...;\n if (lock.tryLock(50L, TimeUnit.SECONDS)) ... Note however, that there is no guarantee that a particular timeout\n implementation will be able to notice the passage of time at the\n same granularity as the given TimeUnit . Since:",
        "org.jabref.logic.util.CoarseChangeFilter": null,
        "org.jabref.model.database.event.AutosaveEvent": null,
        "org.jabref.model.database.event.BibDatabaseContextChangedEvent": null,
        "com.google.common.eventbus.EventBus": null,
        "com.google.common.eventbus.Subscribe": null,
        "org.jabref.gui.util": null,
        "com.tobiasdiez.easybind.EasyBind": null,
        "com.tobiasdiez.easybind.PreboundBinding": null,
        "com.tobiasdiez.easybind.Subscription": null,
        "javafx.beans.binding.BooleanBinding": "BooleanBinding (JavaFX 21) JavaScript is disabled on your browser. Skip navigation links JavaFX\u00a021 Overview Module Package Class Use Tree New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr | Method Detail: Field\u00a0| Constr | Method SEARCH Module javafx.base Package javafx.beans.binding Class BooleanBinding java.lang.Object javafx.beans.binding.BooleanExpression javafx.beans.binding.BooleanBinding All Implemented Interfaces: Binding < Boolean > , Observable , ObservableBooleanValue , ObservableValue < Boolean > public abstract class BooleanBinding extends BooleanExpression implements Binding < Boolean > Base class that provides most of the functionality needed to implement a Binding of a boolean value. BooleanBinding provides a simple invalidation-scheme. An extending\n class can register dependencies by calling bind(Observable...) .\n If One of the registered dependencies becomes invalid, this BooleanBinding is marked as invalid. With unbind(Observable...) listening to dependencies can be stopped. To provide a concrete implementation of this class, the method computeValue() has to be implemented to calculate the value of this\n binding based on the current state of the dependencies. It is called when get() is called for an invalid binding. See DoubleBinding for an example how this base class can be extended. Since:",
        "javafx.beans.binding.ObjectBinding": "ObjectBinding (JavaFX 21) JavaScript is disabled on your browser. Skip navigation links JavaFX\u00a021 Overview Module Package Class Use Tree New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr | Method Detail: Field\u00a0| Constr | Method SEARCH Module javafx.base Package javafx.beans.binding Class ObjectBinding<T> java.lang.Object javafx.beans.binding.ObjectExpression <T> javafx.beans.binding.ObjectBinding<T> Type Parameters: T - the type of the wrapped Object All Implemented Interfaces: Binding <T> , Observable , ObservableObjectValue <T> , ObservableValue <T> public abstract class ObjectBinding<T> extends ObjectExpression <T>\nimplements Binding <T> Base class that provides most of the functionality needed to implement a Binding of an Object . ObjectBinding provides a simple invalidation-scheme. An extending\n class can register dependencies by calling bind(Observable...) .\n If One of the registered dependencies becomes invalid, this ObjectBinding is marked as invalid. With unbind(Observable...) listening to dependencies can be stopped. To provide a concrete implementation of this class, the method computeValue() has to be implemented to calculate the value of this\n binding based on the current state of the dependencies. It is called when get() is called for an invalid binding. See DoubleBinding for an example how this base class can be extended. Since:",
        "javafx.beans.binding.StringBinding": "StringBinding (JavaFX 21) JavaScript is disabled on your browser. Skip navigation links JavaFX\u00a021 Overview Module Package Class Use Tree New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr | Method Detail: Field\u00a0| Constr | Method SEARCH Module javafx.base Package javafx.beans.binding Class StringBinding java.lang.Object javafx.beans.binding.StringExpression javafx.beans.binding.StringBinding All Implemented Interfaces: Binding < String > , Observable , ObservableObjectValue < String > , ObservableStringValue , ObservableValue < String > public abstract class StringBinding extends StringExpression implements Binding < String > Base class that provides most of the functionality needed to implement a Binding of a String . StringBinding provides a simple invalidation-scheme. An extending\n class can register dependencies by calling bind(Observable...) .\n If One of the registered dependencies becomes invalid, this StringBinding is marked as invalid. With unbind(Observable...) listening to dependencies can be stopped. To provide a concrete implementation of this class, the method computeValue() has to be implemented to calculate the value of this\n binding based on the current state of the dependencies. It is called when get() is called for an invalid binding. See DoubleBinding for an example how this base class can be extended. Since:",
        "javafx.beans.property.ListProperty": "ListProperty (JavaFX 21) JavaScript is disabled on your browser. Skip navigation links JavaFX\u00a021 Overview Module Package Class Use Tree New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr | Method Detail: Field\u00a0| Constr | Method SEARCH Module javafx.base Package javafx.beans.property Class ListProperty<E> java.lang.Object javafx.beans.binding.ListExpression <E> javafx.beans.property.ReadOnlyListProperty <E> javafx.beans.property.ListProperty<E> Type Parameters: E - the type of the List elements All Implemented Interfaces: Iterable <E> , Collection <E> , List <E> , Observable , Property < ObservableList <E>> , ReadOnlyProperty < ObservableList <E>> , ObservableListValue <E> , ObservableObjectValue < ObservableList <E>> , ObservableValue < ObservableList <E>> , WritableListValue <E> , WritableObjectValue < ObservableList <E>> , WritableValue < ObservableList <E>> , ObservableList <E> Direct Known Subclasses: ListPropertyBase public abstract class ListProperty<E> extends ReadOnlyListProperty <E>\nimplements Property < ObservableList <E>>, WritableListValue <E> This class provides a full implementation of a Property wrapping an ObservableList .\n\n The value of a ListProperty can be get and set with ObservableObjectValue.get() , ListExpression.getValue() , WritableObjectValue.set(Object) , and setValue(ObservableList) .\n\n A property can be bound and unbound unidirectional with Property.bind(javafx.beans.value.ObservableValue) and Property.unbind() . Bidirectional bindings\n can be created and removed with bindBidirectional(Property) and unbindBidirectional(Property) .\n\n The context of a ListProperty can be read with ReadOnlyProperty.getBean() and ReadOnlyProperty.getName() . Since:",
        "javafx.beans.property.Property": "Property (JavaFX 21) JavaScript is disabled on your browser. Skip navigation links JavaFX\u00a021 Overview Module Package Class Use Tree New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr\u00a0| Method Detail: Field\u00a0| Constr\u00a0| Method SEARCH Module javafx.base Package javafx.beans.property Interface Property<T> Type Parameters: T - the type of the wrapped value All Superinterfaces: Observable , ObservableValue <T> , ReadOnlyProperty <T> , WritableValue <T> All Known Subinterfaces: JavaBeanProperty <T> All Known Implementing Classes: BooleanProperty , BooleanPropertyBase , DoubleProperty , DoublePropertyBase , FloatProperty , FloatPropertyBase , IntegerProperty , IntegerPropertyBase , JavaBeanBooleanProperty , JavaBeanDoubleProperty , JavaBeanFloatProperty , JavaBeanIntegerProperty , JavaBeanLongProperty , JavaBeanObjectProperty , JavaBeanStringProperty , ListProperty , ListPropertyBase , LongProperty , LongPropertyBase , MapProperty , MapPropertyBase , ObjectProperty , ObjectPropertyBase , ReadOnlyBooleanWrapper , ReadOnlyDoubleWrapper , ReadOnlyFloatWrapper , ReadOnlyIntegerWrapper , ReadOnlyListWrapper , ReadOnlyLongWrapper , ReadOnlyMapWrapper , ReadOnlyObjectWrapper , ReadOnlySetWrapper , ReadOnlyStringWrapper , SetProperty , SetPropertyBase , SimpleBooleanProperty , SimpleDoubleProperty , SimpleFloatProperty , SimpleIntegerProperty , SimpleListProperty , SimpleLongProperty , SimpleMapProperty , SimpleObjectProperty , SimpleSetProperty , SimpleStringProperty , SimpleStyleableBooleanProperty , SimpleStyleableDoubleProperty , SimpleStyleableFloatProperty , SimpleStyleableIntegerProperty , SimpleStyleableLongProperty , SimpleStyleableObjectProperty , SimpleStyleableStringProperty , StringProperty , StringPropertyBase , StyleableBooleanProperty , StyleableDoubleProperty , StyleableFloatProperty , StyleableIntegerProperty , StyleableLongProperty , StyleableObjectProperty , StyleableStringProperty public interface Property<T> extends ReadOnlyProperty <T>, WritableValue <T> Generic interface that defines the methods common to all (writable)\n properties, independent of their type. Since:",
        "javafx.beans.value.ChangeListener": "ChangeListener (JavaFX 21) JavaScript is disabled on your browser. Skip navigation links JavaFX\u00a021 Overview Module Package Class Use Tree New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr\u00a0| Method Detail: Field\u00a0| Constr\u00a0| Method SEARCH Module javafx.base Package javafx.beans.value Interface ChangeListener<T> All Known Implementing Classes: WeakChangeListener Functional Interface: This is a functional interface and can therefore be used as the assignment target for a lambda expression or method reference. @FunctionalInterface public interface ChangeListener<T> A ChangeListener is notified whenever the value of an ObservableValue changes. It can be registered and unregistered with ObservableValue.addListener(ChangeListener) respectively ObservableValue.removeListener(ChangeListener) For an in-depth explanation of change events and how they differ from\n invalidation events, see the documentation of ObservableValue . The same instance of ChangeListener can be registered to listen to\n multiple ObservableValues . Since:",
        "javafx.beans.value.ObservableValue": "ObservableValue (JavaFX 21) JavaScript is disabled on your browser. Skip navigation links JavaFX\u00a021 Overview Module Package Class Use Tree New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr\u00a0| Method Detail: Field\u00a0| Constr\u00a0| Method SEARCH Module javafx.base Package javafx.beans.value Interface ObservableValue<T> Type Parameters: T - The type of the wrapped value. All Superinterfaces: Observable All Known Subinterfaces: Binding <T> , JavaBeanProperty <T> , NumberBinding , NumberExpression , ObservableBooleanValue , ObservableDoubleValue , ObservableFloatValue , ObservableIntegerValue , ObservableListValue <E> , ObservableLongValue , ObservableMapValue <K, V> , ObservableNumberValue , ObservableObjectValue <T> , ObservableSetValue <E> , ObservableStringValue , Property <T> , ReadOnlyJavaBeanProperty <T> , ReadOnlyProperty <T> , TextInputControl.Content All Known Implementing Classes: BooleanBinding , BooleanExpression , BooleanProperty , BooleanPropertyBase , DoubleBinding , DoubleExpression , DoubleProperty , DoublePropertyBase , FloatBinding , FloatExpression , FloatProperty , FloatPropertyBase , IntegerBinding , IntegerExpression , IntegerProperty , IntegerPropertyBase , JavaBeanBooleanProperty , JavaBeanDoubleProperty , JavaBeanFloatProperty , JavaBeanIntegerProperty , JavaBeanLongProperty , JavaBeanObjectProperty , JavaBeanStringProperty , ListBinding , ListExpression , ListProperty , ListPropertyBase , LongBinding , LongExpression , LongProperty , LongPropertyBase , MapBinding , MapExpression , MapProperty , MapPropertyBase , NumberExpressionBase , ObjectBinding , ObjectExpression , ObjectProperty , ObjectPropertyBase , ObservableValueBase , ReadOnlyBooleanProperty , ReadOnlyBooleanPropertyBase , ReadOnlyBooleanWrapper , ReadOnlyDoubleProperty , ReadOnlyDoublePropertyBase , ReadOnlyDoubleWrapper , ReadOnlyFloatProperty , ReadOnlyFloatPropertyBase , ReadOnlyFloatWrapper , ReadOnlyIntegerProperty , ReadOnlyIntegerPropertyBase , ReadOnlyIntegerWrapper , ReadOnlyJavaBeanBooleanProperty , ReadOnlyJavaBeanDoubleProperty , ReadOnlyJavaBeanFloatProperty , ReadOnlyJavaBeanIntegerProperty , ReadOnlyJavaBeanLongProperty , ReadOnlyJavaBeanObjectProperty , ReadOnlyJavaBeanStringProperty , ReadOnlyListProperty , ReadOnlyListPropertyBase , ReadOnlyListWrapper , ReadOnlyLongProperty , ReadOnlyLongPropertyBase , ReadOnlyLongWrapper , ReadOnlyMapProperty , ReadOnlyMapPropertyBase , ReadOnlyMapWrapper , ReadOnlyObjectProperty , ReadOnlyObjectPropertyBase , ReadOnlyObjectWrapper , ReadOnlySetProperty , ReadOnlySetPropertyBase , ReadOnlySetWrapper , ReadOnlyStringProperty , ReadOnlyStringPropertyBase , ReadOnlyStringWrapper , SetBinding , SetExpression , SetProperty , SetPropertyBase , SimpleBooleanProperty , SimpleDoubleProperty , SimpleFloatProperty , SimpleIntegerProperty , SimpleListProperty , SimpleLongProperty , SimpleMapProperty , SimpleObjectProperty , SimpleSetProperty , SimpleStringProperty , SimpleStyleableBooleanProperty , SimpleStyleableDoubleProperty , SimpleStyleableFloatProperty , SimpleStyleableIntegerProperty , SimpleStyleableLongProperty , SimpleStyleableObjectProperty , SimpleStyleableStringProperty , StringBinding , StringExpression , StringProperty , StringPropertyBase , StyleableBooleanProperty , StyleableDoubleProperty , StyleableFloatProperty , StyleableIntegerProperty , StyleableLongProperty , StyleableObjectProperty , StyleableStringProperty public interface ObservableValue<T> extends Observable An ObservableValue is an entity that wraps a value and allows to\n observe the value for changes. In general this interface should not be\n implemented directly but one of its sub-interfaces\n ( ObservableBooleanValue etc.). The value of the ObservableValue can be requested with getValue() . An implementation of ObservableValue may support lazy evaluation,\n which means that the value is not immediately recomputed after changes, but\n lazily the next time the value is requested (see note 1 in \"Implementation Requirements\"). An ObservableValue generates two types of events: change events and\n invalidation events. A change event indicates that the value has changed\n (see note 2 in \"Implementation Requirements\"). An\n invalidation event is generated if the current value is not valid anymore.\n This distinction becomes important if the ObservableValue supports\n lazy evaluation, because for a lazily evaluated value one does not know if an\n invalid value really has changed until it is recomputed. For this reason,\n generating change events requires eager evaluation while invalidation events\n can be generated for eager and lazy implementations. Implementations of this class should strive to generate as few events as\n possible to avoid wasting too much time in event handlers. Implementations in\n this library mark themselves as invalid when the first invalidation event\n occurs. They do not generate any more invalidation events until their value is\n recomputed and valid again. Two types of listeners can be attached to an ObservableValue : InvalidationListener to listen to invalidation events and ChangeListener to listen to change events. Important note: attaching a ChangeListener enforces eager computation\n even if the implementation of the ObservableValue supports lazy\n evaluation. Implementation Requirements: All bindings and properties in the JavaFX library support lazy evaluation. All implementing classes in the JavaFX library check for a change using reference\n equality (and not object equality, Object#equals(Object) ) of the value. Since:",
        "javafx.collections.*": null,
        "javafx.css.PseudoClass": "PseudoClass (JavaFX 21) JavaScript is disabled on your browser. Skip navigation links JavaFX\u00a021 Overview Module Package Class Use Tree New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr | Method Detail: Field\u00a0| Constr | Method SEARCH Module javafx.graphics Package javafx.css Class PseudoClass java.lang.Object javafx.css.PseudoClass public abstract class PseudoClass extends Object PseudoClass represents one unique pseudo-class state. Introducing a\n pseudo-class into a JavaFX class only requires that the method Node.pseudoClassStateChanged(javafx.css.PseudoClass, boolean) be called when the pseudo-class state changes. Typically, the pseudoClassStateChanged method is called from the protected void invalidated() method of one of the property base\n classes in the javafx.beans.property package. Note that if a node has a default pseudo-class state, a horizontal orientation\n for example, pseudoClassStateChanged should be called from the\n constructor to set the initial state. The following example would allow \"xyzzy\" to be used as a\n  pseudo-class in a CSS selector. public boolean isMagic() {\n       return magic.get();\n   }\n\n   public BooleanProperty magicProperty() {\n       return magic;\n   }\n\n   public BooleanProperty magic =\n       new BooleanPropertyBase(false) {\n\n       @Override protected void invalidated() {\n           pseudoClassStateChanged(MAGIC_PSEUDO_CLASS, get());\n       }\n\n       @Override public Object getBean() {\n           return MyControl.this;\n       }\n\n       @Override public String getName() {\n           return \"magic\";\n       }\n   }\n\n   private static final PseudoClass\n       MAGIC_PSEUDO_CLASS = PseudoClass.getPseudoClass(\"xyzzy\"); Since:",
        "javafx.scene.Node": "Node (JavaFX 21) JavaScript is disabled on your browser. Skip navigation links JavaFX\u00a021 Overview Module Package Class Use Tree New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field | Constr | Method Detail: Field | Constr | Method SEARCH Module javafx.graphics Package javafx.scene Class Node java.lang.Object javafx.scene.Node All Implemented Interfaces: Styleable , EventTarget Direct Known Subclasses: Camera , Canvas , ImageView , LightBase , MediaView , Parent , Shape , Shape3D , SubScene , SwingNode @IDProperty(\"id\") public abstract class Node extends Object implements EventTarget , Styleable Base class for scene graph nodes. A scene graph is a set of tree data structures\n where every item has zero or one parent, and each item is either\n a \"leaf\" with zero sub-items or a \"branch\" with zero or more sub-items. Each item in the scene graph is called a Node . Branch nodes are\n of type Parent , whose concrete subclasses are Group , Region , and Control ,\n or subclasses thereof. Leaf nodes are classes such as Rectangle , Text , ImageView , MediaView ,\n or other such leaf classes which cannot have children. Only a single node within\n each scene graph tree will have no parent, which is referred to as the \"root\" node. There may be several trees in the scene graph. Some trees may be part of\n a Scene , in which case they are eligible to be displayed.\n Other trees might not be part of any Scene . A node may occur at most once anywhere in the scene graph. Specifically,\n a node must appear no more than once in all of the following:\n as the root node of a Scene ,\n the children ObservableList of a Parent ,\n or as the clip of a Node . The scene graph must not have cycles. A cycle would exist if a node is\n an ancestor of itself in the tree, considering the Group content\n ObservableList, Parent children ObservableList, and Node clip relationships\n mentioned above. If a program adds a child node to a Parent (including Group, Region, etc)\n and that node is already a child of a different Parent or the root of a Scene,\n the node is automatically (and silently) removed from its former parent.\n If a program attempts to modify the scene graph in any other way that violates\n the above rules, an exception is thrown, the modification attempt is ignored\n and the scene graph is restored to its previous state. It is possible to rearrange the structure of the scene graph, for\n example, to move a subtree from one location in the scene graph to\n another. In order to do this, one would normally remove the subtree from\n its old location before inserting it at the new location. However, the\n subtree will be automatically removed as described above if the application\n doesn't explicitly remove it. Node objects may be constructed and modified on any thread as long they are\n not yet attached to a Scene in a Window that is showing .\n An application must attach nodes to such a Scene or modify them on the JavaFX\n Application Thread. The JavaFX Application Thread is created as part of the startup process for\n the JavaFX runtime. See the Application class and\n the Platform.startup(Runnable) method for more information. An application should not extend the Node class directly. Doing so may lead to\n an UnsupportedOperationException being thrown. String ID Each node in the scene graph can be given a unique id . This id is\n much like the \"id\" attribute of an HTML tag in that it is up to the designer\n and developer to ensure that the id is unique within the scene graph.\n A convenience function called lookup(String) can be used to find\n a node with a unique id within the scene graph, or within a subtree of the\n scene graph. The id can also be used identify nodes for applying styles; see\n the CSS section below. Coordinate System The Node class defines a traditional computer graphics \"local\"\n coordinate system in which the x axis increases to the right and the y axis increases downwards.  The concrete node classes for shapes\n provide variables for defining the geometry and location of the shape\n within this local coordinate space.  For example, Rectangle provides x , y , width , height variables while Circle provides centerX , centerY ,\n and radius . At the device pixel level, integer coordinates map onto the corners and\n cracks between the pixels and the centers of the pixels appear at the\n midpoints between integer pixel locations.  Because all coordinate values\n are specified with floating point numbers, coordinates can precisely\n point to these corners (when the floating point values have exact integer\n values) or to any location on the pixel.  For example, a coordinate of (0.5, 0.5) would point to the center of the upper left pixel on the Stage .  Similarly, a rectangle at (0, 0) with dimensions\n of 10 by 10 would span from the upper left corner of the\n upper left pixel on the Stage to the lower right corner of the\n 10th pixel on the 10th scanline.  The pixel center of the last pixel\n inside that rectangle would be at the coordinates (9.5, 9.5) . In practice, most nodes have transformations applied to their coordinate\n system as mentioned below.  As a result, the information above describing\n the alignment of device coordinates to the pixel grid is relative to\n the transformed coordinates, not the local coordinates of the nodes.\n The Shape class describes some additional\n important context-specific information about coordinate mapping and how\n it can affect rendering. Transformations Any Node can have transformations applied to it. These include\n translation, rotation, scaling, or shearing. A translation transformation is one which shifts the origin of the\n node's coordinate space along either the x or y axis. For example, if you\n create a Rectangle which is drawn at the origin\n (x=0, y=0) and has a width of 100 and a height of 50, and then apply a Translate with a shift of 10 along the x axis\n (x=10), then the rectangle will appear drawn at (x=10, y=0) and remain\n 100 points wide and 50 tall. Note that the origin was shifted, not the x variable of the rectangle. A common node transform is a translation by an integer distance, most often\n used to lay out nodes on the stage.  Such integer translations maintain the\n device pixel mapping so that local coordinates that are integers still\n map to the cracks between pixels. A rotation transformation is one which rotates the coordinate space of\n the node about a specified \"pivot\" point, causing the node to appear rotated.\n For example, if you create a Rectangle which is\n drawn at the origin (x=0, y=0) and has a width of 100 and height of 30 and\n you apply a Rotate with a 90 degree rotation\n (angle=90) and a pivot at the origin (pivotX=0, pivotY=0), then\n the rectangle will be drawn as if its x and y were zero but its height was\n 100 and its width -30. That is, it is as if a pin is being stuck at the top\n left corner and the rectangle is rotating 90 degrees clockwise around that\n pin. If the pivot point is instead placed in the center of the rectangle\n (at point x=50, y=15) then the rectangle will instead appear to rotate about\n its center. Note that as with all transformations, the x, y, width, and height variables\n of the rectangle (which remain relative to the local coordinate space) have\n not changed, but rather the transformation alters the entire coordinate space\n of the rectangle. A scaling transformation causes a node to either appear larger or\n smaller depending on the scaling factor. Scaling alters the coordinate space\n of the node such that each unit of distance along the axis in local\n coordinates is multiplied by the scale factor. As with rotation\n transformations, scaling transformations are applied about a \"pivot\" point.\n You can think of this as the point in the Node around which you \"zoom\".  For\n example, if you create a Rectangle with a strokeWidth of 5, and a width and height of 50, and you apply a Scale with scale factors (x=2.0, y=2.0) and\n a pivot at the origin (pivotX=0, pivotY=0), the entire rectangle\n (including the stroke) will double in size, growing to the right and\n downwards from the origin. A shearing transformation, sometimes called a skew, effectively\n rotates one axis so that the x and y axes are no longer perpendicular. Multiple transformations may be applied to a node. Custom transforms are applied using the transforms list. Predefined transforms are applied using the properties specified below.\n The matrices that represent the transforms are multiplied in this order: Layout ( layoutX , layoutY ) and translate\n ( translateX , translateY , translateZ ) Rotate ( rotate ) Scale ( scaleX , scaleY , scaleZ ) Transforms list ( transforms ) starting from element 0 The transforms are applied in the reverse order of the matrix multiplication outlined above: last element of the transforms list\n to 0th element, scale, rotate, and layout and translate. By applying the transforms in this order, the bounds in the local\n coordinates of the node are transformed to the bounds in the parent coordinate of the node (see the Bounding Rectangles section). Bounding Rectangles Since every",
        "java.util.Map": "Map (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested | Field\u00a0| Constr\u00a0| Method Detail: Field\u00a0| Constr\u00a0| Method SEARCH Module java.base Package java.util Interface Map<K, V> Type Parameters: K - the type of keys maintained by this map V - the type of mapped values All Known Subinterfaces: Bindings , ConcurrentMap <K, V> , ConcurrentNavigableMap <K, V> , NavigableMap <K, V> , SequencedMap <K, V> , SortedMap <K, V> All Known Implementing Classes: AbstractMap , Attributes , AuthProvider , ConcurrentHashMap , ConcurrentSkipListMap , EnumMap , HashMap , Hashtable , Headers , IdentityHashMap , LinkedHashMap , PrinterStateReasons , Properties , Provider , RenderingHints , SimpleBindings , TabularDataSupport , TreeMap , UIDefaults , WeakHashMap public interface Map<K, V> An object that maps keys to values.  A map cannot contain duplicate keys;\n each key can map to at most one value. This interface takes the place of the Dictionary class, which\n was a totally abstract class rather than an interface. The Map interface provides three collection views , which\n allow a map's contents to be viewed as a set of keys, collection of values,\n or set of key-value mappings.  The order of a map is defined as\n the order in which the iterators on the map's collection views return their\n elements.  Some map implementations, like the TreeMap class, make\n specific guarantees as to their encounter order; others, like the HashMap class, do not. Maps with a defined encounter order are generally subtypes of the SequencedMap interface. Note: great care must be exercised if mutable objects are used as map\n keys.  The behavior of a map is not specified if the value of an object is\n changed in a manner that affects equals comparisons while the\n object is a key in the map.  A special case of this prohibition is that it\n is not permissible for a map to contain itself as a key.  While it is\n permissible for a map to contain itself as a value, extreme caution is\n advised: the equals and hashCode methods are no longer\n well defined on such a map. All general-purpose map implementation classes should provide two\n \"standard\" constructors: a void (no arguments) constructor which creates an\n empty map, and a constructor with a single argument of type Map ,\n which creates a new map with the same key-value mappings as its argument.\n In effect, the latter constructor allows the user to copy any map,\n producing an equivalent map of the desired class.  There is no way to\n enforce this recommendation (as interfaces cannot contain constructors) but\n all of the general-purpose map implementations in the JDK comply. The \"destructive\" methods contained in this interface, that is, the\n methods that modify the map on which they operate, are specified to throw UnsupportedOperationException if this map does not support the\n operation.  If this is the case, these methods may, but are not required\n to, throw an UnsupportedOperationException if the invocation would\n have no effect on the map.  For example, invoking the putAll(Map) method on an unmodifiable map may, but is not required to, throw the\n exception if the map whose mappings are to be \"superimposed\" is empty. Some map implementations have restrictions on the keys and values they\n may contain.  For example, some implementations prohibit null keys and\n values, and some have restrictions on the types of their keys.  Attempting\n to insert an ineligible key or value throws an unchecked exception,\n typically NullPointerException or ClassCastException .\n Attempting to query the presence of an ineligible key or value may throw an\n exception, or it may simply return false; some implementations will exhibit\n the former behavior and some will exhibit the latter.  More generally,\n attempting an operation on an ineligible key or value whose completion\n would not result in the insertion of an ineligible element into the map may\n throw an exception or it may succeed, at the option of the implementation.\n Such exceptions are marked as \"optional\" in the specification for this\n interface. Many methods in Collections Framework interfaces are defined\n in terms of the equals method.  For\n example, the specification for the containsKey(Object key) method says: \"returns true if and\n only if this map contains a mapping for a key k such that (key==null ? k==null : key.equals(k)) .\" This specification should not be construed to imply that invoking Map.containsKey with a non-null argument key will cause key.equals(k) to\n be invoked for any key k .  Implementations are free to\n implement optimizations whereby the equals invocation is avoided,\n for example, by first comparing the hash codes of the two keys.  (The Object.hashCode() specification guarantees that two objects with\n unequal hash codes cannot be equal.)  More generally, implementations of\n the various Collections Framework interfaces are free to take advantage of\n the specified behavior of underlying Object methods wherever the\n implementor deems it appropriate. Some map operations which perform recursive traversal of the map may fail\n with an exception for self-referential instances where the map directly or\n indirectly contains itself. This includes the clone() , equals() , hashCode() and toString() methods.\n Implementations may optionally handle the self-referential scenario, however\n most current implementations do not do so. Unmodifiable Maps The Map.of , Map.ofEntries , and Map.copyOf static factory methods provide a convenient way to create unmodifiable maps.\n The Map instances created by these methods have the following characteristics: They are unmodifiable . Keys and values\n cannot be added, removed, or updated. Calling any mutator method on the Map\n will always cause UnsupportedOperationException to be thrown.\n However, if the contained keys or values are themselves mutable, this may cause the\n Map to behave inconsistently or its contents to appear to change. They disallow null keys and values. Attempts to create them with null keys or values result in NullPointerException . They are serializable if all keys and values are serializable. They reject duplicate keys at creation time. Duplicate keys\n passed to a static factory method result in IllegalArgumentException . The iteration order of mappings is unspecified and is subject to change. They are value-based .\n Programmers should treat instances that are equal as interchangeable and should not use them for synchronization, or\n unpredictable behavior may occur. For example, in a future release,\n synchronization may fail. Callers should make no assumptions\n about the identity of the returned instances. Factories are free to\n create new instances or reuse existing ones. They are serialized as specified on the Serialized Form page. This interface is a member of the Java Collections Framework . Since:",
        "java.util.function.Consumer": "Consumer (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr\u00a0| Method Detail: Field\u00a0| Constr\u00a0| Method SEARCH Module java.base Package java.util.function Interface Consumer<T> Type Parameters: T - the type of the input to the operation All Known Subinterfaces: Stream.Builder <T> Functional Interface: This is a functional interface and can therefore be used as the assignment target for a lambda expression or method reference. @FunctionalInterface public interface Consumer<T> Represents an operation that accepts a single input argument and returns no\n result. Unlike most other functional interfaces, Consumer is expected\n to operate via side-effects. This is a functional interface whose functional method is accept(Object) . Since:",
        "java.util.function.Function": "Function (Java SE 21 & JDK 21) JavaScript is disabled on your browser. Skip navigation links Java SE 21 & JDK 21 Overview Module Package Class Use Tree Preview New Deprecated Index Help Summary: Nested Field Constr Method Detail: Field Constr Method Summary: Nested\u00a0| Field\u00a0| Constr\u00a0| Method Detail: Field\u00a0| Constr\u00a0| Method SEARCH Module java.base Package java.util.function Interface Function<T, R> Type Parameters: T - the type of the input to the function R - the type of the result of the function All Known Subinterfaces: UnaryOperator <T> Functional Interface: This is a functional interface and can therefore be used as the assignment target for a lambda expression or method reference. @FunctionalInterface public interface Function<T, R> Represents a function that accepts one argument and produces a result. This is a functional interface whose functional method is apply(Object) . Since:"
    },
    "functions": {
        "util": "I'm sorry, but I need a specific Java method to provide you with the summarized description. Could you please provide the Java method for which you would like to see the description?",
        "List": "\"List\": \"A collection designed to hold elements prior to processing\"",
        "Map": "'Map': 'An object that maps keys to values. A map cannot contain duplicate keys; each key can map to at most one value.'",
        "function": "I'm sorry, but I need a specific Java method to provide you with a summarized description. Could you please provide the name of a Java method?",
        "pseudoClassStateChanged": "'pseudoClassStateChanged': 'Method description not found'",
        "subscribe": "'subscribe': 'Method description not found'",
        "accept": "'accept': 'This method is not found in Java documentation.'",
        "getValue": "'getValue': 'not found'",
        "setValue": "'setValue': 'Sets the value of the specified element in the list.'",
        "addListener": "'addListener': 'Registers a listener to be notified when events of a certain type occur.'",
        "setAll": "'setAll': 'Sets all elements in the list to the specified element'",
        "map": "'map': 'Transforms each element of the stream using the provided function.'",
        "removeListener": "'removeListener': 'Removes the specified listener from receiving notifications when the event occurs.'",
        "HashSet": "'HashSet': 'This class implements the Set interface, backed by a hash table which provides constant-time performance for the basic operations (add, contains, remove and size).'",
        "Set": "\"Set\": \"A collection that contains no duplicate elements.\"",
        "concurrent": "I'm sorry, but I cannot provide assistance without a specific Java method to work with. Could you please provide the name of a Java method for which you need a summarized description?",
        "CoarseChangeFilter": "'CoarseChangeFilter': 'Filters changes based on a coarse granularity'",
        "getLogger": "'getLogger': 'Gets the logger for the specified name'",
        "registerListener": "'registerListener': 'Registers a listener to receive notifications about changes to the data set.'",
        "SECONDS": "'SECONDS': 'Represents the number of seconds'",
        "submit": "'submit': 'Submit the task for execution'",
        "post": "'post': 'Send a POST request to the specified URL'",
        "debug": "'debug': 'not found'",
        "unregisterListener": "'unregisterListener': 'Unregisters a previously registered listener.'",
        "shutdown": "'shutdown': 'Shuts down the ExecutorService'",
        "add": "'add': 'Adds the specified element to the end of the list.'",
        "stream": "'stream': 'A sequence of elements supporting sequential and parallel aggregate operations.'",
        "filter": "'filter': 'Creates a new stream with elements that satisfy the given predicate.'",
        "findAny": "'findAny': 'Returns an Optional describing some element of the stream, or an empty Optional if the stream is empty.'",
        "ifPresent": "'ifPresent': 'If a value is present, invoke the specified consumer with the value, otherwise do nothing.'",
        "remove": "'remove': 'Removes the first occurrence of the specified element from this list, if it is present.'",
        "register": "'register': 'Registers the specified object with this notification broadcaster.'",
        "unregister": "'unregister': 'Unregisters the MBean specified by the ObjectName.'",
        "Optional": "'Optional': 'A container object which may or may not contain a non-null value.'",
        "getSystemClipboard": "'getSystemClipboard': 'Get the system clipboard'",
        "getDefaultToolkit": "'getDefaultToolkit': 'This method gets the default toolkit.'",
        "getSystemSelection": "'getSystemSelection': 'Retrieve the current system selection.'",
        "selectedTextProperty": "'selectedTextProperty': 'not found'",
        "runLater": "'runLater': 'Executes the specified action on the JavaFX Application Thread at some unspecified time in the future.'",
        "getSelectedText": "'getSelectedText': 'Returns the selected text in the current document or null if no text is selected.'",
        "setContents": "'setContents': 'Sets the contents of this object.'",
        "setOnMouseClicked": "'setOnMouseClicked': 'Sets a function to be called when a mouse click event occurs on the node.'",
        "getButton": "'getButton': 'Retrieve the button associated with this event'",
        "MIDDLE": "'MIDDLE': 'Returns the middle element of the given array'",
        "insertText": "'insertText': 'Inserts the specified text at the current caret position in the text component.'",
        "getCaretPosition": "'getCaretPosition': 'Returns the position of the text insertion caret in the text component.'",
        "getString": "'getString': 'Returns the value of the specified column as a String.'",
        "ofNullable": "'ofNullable': 'Returns an Optional describing the specified value, if non-null, otherwise returns an empty Optional.'",
        "getContent": "'getContent': 'This method is not found in the Java documentation.'",
        "class": "Please provide the Java class name for which you need the method description.",
        "getContents": "'getContents': 'Retrieve the contents of the object'",
        "isDataFlavorSupported": "'isDataFlavorSupported': 'Indicates whether the specified data flavor is supported for this object.'",
        "stringFlavor": "stringFlavor: The method \"stringFlavor\" was not found in the Java documentation.",
        "getTransferData": "'getTransferData': 'Returns the data to be transferred with this transferable.'",
        "warn": "'warn': 'This method is not found in the Java documentation.'",
        "getMessage": "'method': 'Obtains the message of this throwable object'",
        "setContent": "'setContent': 'Sets the content of this object.'",
        "putHtml": "'putHtml': 'Inserts the specified HTML at the end of the element.'",
        "putString": "'putString': 'Inserts a specified string into the current StringBuilder object at the specified position.'",
        "getFieldWriterPreferences": "'getFieldWriterPreferences': 'Retrieve the preferences for writing fields in a document.'",
        "serializeAll": "'serializeAll': 'Method description not found'",
        "BIBTEX": "I'm sorry, but I couldn't find any information on a method related to BIBTEX.",
        "put": "'put': 'Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions, returning true upon success and throwing an IllegalStateException if no space is currently available.'",
        "transformers": "'transformers': 'not found'",
        "JsonReader": "'JsonReader': 'Parses a JSON-encoded string into a stream of tokens.'",
        "strings": "\"strings\": \"This method returns the empty string.\"",
        "StandardField": "I'm sorry, but I cannot provide a summary for the method \"StandardField\" as the description was not found.",
        "OptionalUtil": "'OptionalUtil': 'not found'",
        "ArrayList": "'ArrayList': 'Resizable-array implementation of the List interface'",
        "Collections": "'Collections': 'This class consists exclusively of static methods that operate on or return collections.'",
        "getLatexFreeField": "'getLatexFreeField': 'Retrieve the LatexFreeField value'",
        "TITLE": "I'm sorry, but I need a Java method and its description to provide a summary. Could you please provide a Java method and its description?",
        "addParameter": "'addParameter': 'Adds a parameter to the current URL query string.'",
        "AUTHOR": "I'm sorry, but I need a specific Java method in order to provide you with the summarized description. Could you please provide the Java method you would like me to summarize?",
        "YEAR": "'YEAR': 'Obtains the value of the specified calendar field.'",
        "build": "'build': 'Constructs a new string by concatenating the specified array of strings.'",
        "toURL": "'toURL': 'Converts this abstract pathname into a file: URL'",
        "transformLuceneQuery": "'transformLuceneQuery': 'Transforms a Lucene query into a different format.'",
        "orElse": "'orElse': 'Returns the value if present, otherwise returns other.'",
        "toJsonObject": "'toJsonObject': 'Converts this JSON object into a JSONObject.'",
        "isEmpty": "'isEmpty': 'Tests if this list is empty.'",
        "emptyList": "'emptyList': 'Creates an empty list.'",
        "getJSONObject": "'getJSONObject': 'Retrieve the value mapped by the specified key as a JSONObject.'",
        "has": "'has': 'Checks if a particular element is present in the collection'",
        "singletonList": "'singletonList': 'Returns an immutable list containing only the specified object. The returned list is serializable.'",
        "getJSONArray": "'getJSONArray': 'Get the JSONArray value associated with a key.'",
        "length": "'length': 'Returns the number of elements in the array'",
        "getField": "'getField': 'Returns the value of the field represented by this Field object on the specified object.'",
        "equals": "'equals': 'Compares this object to the specified object'",
        "SUBTITLE": "I'm sorry, but I need a Java method and its description to provide a summary. Could you please provide that information?",
        "cleanup": "'cleanup': 'No description found'",
        "setType": "setType: This method is not found in Java documentation.",
        "setField": "'setField': 'Method description not found'",
        "optJSONArray": "'optJSONArray': 'Returns the value mapped by name if it exists and is a JSONArray, or null otherwise.'",
        "optJSONObject": "'optJSONObject': 'Returns the value mapped by the specified key, or null if no mapping for the key is found.'",
        "DOI": "I'm sorry, but I couldn't find any information related to the DOI. Could you please provide me with the Java method and its description so I can assist you further?",
        "PAGES": "'PAGES': 'not found'",
        "optString": "'optString': 'Returns the value mapped by the given key, or defaultValue if no such mapping exists'",
        "VOLUME": "'VOLUME': 'This method is not found in Java documentation.'",
        "ISSN": "'ISSN': 'The International Standard Serial Number (ISSN) is an eight-digit number used to uniquely identify a print or electronic periodical publication.'",
        "range": "'range': 'not found'",
        "mapToObj": "'mapToObj': 'Transforms each element of this stream into a new stream of objects and returns a Stream consisting of those objects.'",
        "collect": "'collect': 'Performs a mutable reduction operation on the elements of this stream using a Collector.'",
        "getAsFirstLastNamesWithAnd": "'getAsFirstLastNamesWithAnd': 'Concatenates the first and last names of a person with \"and\" in between'",
        "Article": "I'm sorry, but I couldn't find any information related to the Java method or its description.",
        "Misc": "I'm sorry, but I cannot provide a summary without the method name. Could you please provide the method name as well?",
        "format": "'format': 'Returns the format string of this formatter.'",
        "isPresentAnd": "'isPresentAnd': 'not found'",
        "isSimilar": "'isSimilar': 'Check if two objects are similar'",
        "getDOI": "'getDOI': 'Retrieve the DOI (Digital Object Identifier) of the current object.'",
        "combine": "'combine': 'Merges the elements of two streams using a combining function, such as addition or concatenation, and returns a new stream as a result.'",
        "empty": "'empty': 'Tests if this collection is empty.'",
        "LatexParserResult": "'LatexParserResult': 'Parse the given LaTeX string and return the result'",
        "Arrays": "'Arrays': 'Utility class for manipulating arrays'",
        "parse": "'parse': 'Parses the text from a string to produce a Date object.'",
        "addKey": "'addKey': 'Adds a key to the collection'",
        "of": "'of': 'not found'",
        "toURI": "'toURI': 'Converts this abstract pathname into a file: URI. The resulting URI consists of a scheme, a host, and a path component. If the abstract pathname is absolute, the URI's path is absolute. If the abstract pathname is relative, the URI's path is relative, and it is resolved against the URI's base URI.'",
        "getFileList": "'getFileList': 'Retrieve a list of files in a directory.'",
        "asList": "'asList': 'Returns a fixed-size list backed by the specified array.'",
        "addAll": "'addAll': 'Adds all of the elements in the specified collection to this collection.'",
        "addBibFile": "'addBibFile': 'Method not found'",
        "getParent": "'getParent': 'Returns the parent of this file or directory.'",
        "resolve": "I'm sorry, but I couldn't find any Java method with the description \"resolve\". Could you please provide the correct method name or more context so I can assist you better?",
        "getNestedFiles": "'getNestedFiles': 'Retrieve a list of all nested files within a directory.'",
        "field": "'field': 'not found'",
        "*": "I'm sorry, but the query provided is not clear. Could you please provide more information or clarify the request?",
        "joining": "'joining': 'Concatenates the elements of the stream into a single String'",
        "FILE": "I'm sorry, but I cannot provide assistance without a specific Java method. Could you please provide the method name or a more detailed query?",
        "URL": "URL: not found",
        "URI": "URI: Uniform Resource Identifier.",
        "ISBN": "'ISBN': 'International Standard Book Number (ISBN) is a unique identifier for books, intended to facilitate the distribution and ordering of books.'",
        "MONTH": "'MONTH': 'Returns the month of the year represented by this Date object. The value returned is between 0 and 11.'",
        "DATE": "DATE: 'not found'",
        "EPRINT": "'EPRINT': 'Prints the text representation of the object to the standard output stream'",
        "PMID": "I'm sorry, but I need a specific Java method in order to provide you with the summarized description. Could you please provide me with the Java method you would like me to summarize?",
        "toCollection": "'toCollection': 'Returns a Collection containing all elements of this stream.'",
        "<": "I'm sorry, but I couldn't find any Java method or description in the query you provided. Could you please provide the Java method and its description so that I can summarize it for you?",
        "fromName": "'fromName': 'not found'",
        "getProperties": "'getProperties': 'Returns a set of system properties'",
        "contains": "'contains': 'This method checks if a certain element is present in a collection.'",
        "getName": "'getName': 'Returns the name of the entity represented by this object.'",
        "startsWith": "'startsWith': 'Checks if a string starts with a specified prefix.'",
        "toSet": "'toSet': 'Converts a collection into a Set containing all the elements of the collection.'",
        "CROSSREF": "I'm sorry, but I couldn't find any information related to the method you provided.",
        "KEYWORDS": "No method provided.",
        "GROUPS": "'GROUPS': 'Not found'",
        "OWNER": "'OWNER': 'not found'",
        "TIMESTAMP": "'Not found': 'Retrieve the description for the method'",
        "ABSTRACT": "Method not found",
        "COMMENT": "'COMMENT': 'This method does not have a description available in the Java documentation.'",
        "REVIEW": "No method provided.",
        "externalfiles": "'externalfiles': 'Method description not found'",
        "externalfiletype": "I'm sorry, but I couldn't find any information related to the Java method or its description based on the provided query. Could you please provide the Java method name or any additional details for me to assist you further?",
        "io": "'io': 'not found'",
        "BibEntry": "'BibEntry': 'Description not found'",
        "LinkedFile": "LinkedFile: None\n\n'LinkedFile': 'not found'",
        "getFirstExistingFileDir": "'getFirstExistingFileDir': 'Find the first existing file or directory in the given list of paths.'",
        "isPresent": "'isPresent': 'Checks if a value is present in the Optional object'",
        "get": "'get': 'Retrieve the value associated with a given key in a map.'",
        "getFileName": "'getFileName': 'Returns the file name of the path'",
        "copyFile": "'copyFile': 'Copy a file from one location to another.'",
        "getFileExtension": "'getFileExtension': 'This method's description was not found in the Java documentation.'",
        "getExternalFileTypeByExt": "'getExternalFileTypeByExt': 'Retrieve the external file type based on the file extension.'",
        "relativize": "'relativize': 'Constructs a relative path between this path and a given path.'",
        "getFileDirectories": "'getFileDirectories': 'Retrieve the list of directories in the specified file path.'",
        "addFile": "'addFile': 'Adds a file to the specified location.'",
        "blockNewTasks": "'blockNewTasks': 'Prevents new tasks from being submitted for execution'",
        "error": "Error: Description not found",
        "addToIndex": "'addToIndex': 'Adds the specified document to this index.'"
    },
    "class_names": {
        "externalfiles": "Utility - Application",
        "ExternalFileType": "Utility - Application",
        "ExternalFileTypes": "Input-Output - Application",
        "UnknownExternalFileType": "Utility - Application",
        "MoveFilesCleanup": "Utility - Application",
        "RenamePdfCleanup": "Utility - Application",
        "IndexingTaskManager": "Software Development and IT Operation - Application",
        "PdfIndexer": "Parser - Application",
        "FileUtil": "Utility - Application",
        "BibDatabaseContext": "Data Structure - Application",
        "BibEntry": "Data Structure - Application",
        "LinkedFile": "Data Structure - Application",
        "FilePreferences": "Utility - Application",
        "Logger": "Logging - Logging",
        "LoggerFactory": "Logging - Application",
        "IOException": "Error Handling - Application",
        "Path": "Data Structure - Network",
        "List": "Data Structure - Parser",
        "Optional": "Language - Parser",
        "field": "Data Structure - Setup",
        "StringUtil": "Utility - Application",
        "OptionalUtil": "Utility - Application",
        "*": "Parser - Parser",
        "Predicate": "Parser - Parser",
        "Collectors": "Utility - Databases",
        "texparser": "Parser - Application",
        "LatexParserResult": "Parser - Application",
        "Test": "Test - Test",
        "URISyntaxException": "Error Handling - Application",
        "Arrays": "Data Structure - Databases",
        "assertEquals": "Test - Application",
        "fetcher": "Utility - Test",
        "JSONArray": "Data Structure - Application",
        "JSONException": "Error Handling - Application",
        "JSONObject": "Data Structure - Application",
        "URIBuilder": "Utility - Application",
        "QueryNode": "Data Structure - Application",
        "FieldFormatterCleanup": "Utility - Application",
        "ClearFormatter": "Utility - Application",
        "RemoveBracesFormatter": "Utility - Application",
        "DefaultQueryTransformer": "Parser - Application",
        "JsonReader": "Parser - Application",
        "StringSimilarity": "Utility - Application",
        "Author": "Interpreter - Interpreter",
        "AuthorList": "Utility - Application",
        "StandardField": "Data Structure - Application",
        "DOI": "Utility - Application",
        "EntryType": "Utility - Application",
        "StandardEntryType": "Data Structure - Application",
        "MalformedURLException": "Error Handling - Application",
        "URL": "Network - Parser",
        "ArrayList": "Data Structure - Parser",
        "Collections": "Data Structure - Databases",
        "IntStream": "Data Structure - Application",
        "gui": "User Interface - Parser",
        "Toolkit": "User Interface - Application",
        "DataFlavor": "User Interface - Application",
        "StringSelection": "User Interface - Application",
        "Transferable": "User Interface - Application",
        "UnsupportedFlavorException": "Error Handling - Application",
        "Platform": "User Interface - Application",
        "TextInputControl": "User Interface - Application",
        "Clipboard": "User Interface - Setup",
        "ClipboardContent": "Computer Graphics - Application",
        "DataFormat": "User Interface - Application",
        "MouseButton": "User Interface - Application",
        "AllowedToUseAwt": "User Interface - Application",
        "BibEntryWriter": "Parser - Application",
        "FieldWriter": "Utility - Application",
        "BibDatabaseMode": "Databases - Application",
        "PreferencesService": "Utility - Application",
        "autosaveandbackup": "Utility - Application",
        "HashSet": "Data Structure - Application",
        "Set": "Data Structure - Setup",
        "ArrayBlockingQueue": "Data Structure - Application",
        "BlockingQueue": "Data Structure - Application",
        "ExecutorService": "Multi-Thread - Application",
        "RejectedExecutionException": "Error Handling - Application",
        "ThreadPoolExecutor": "Multi-Thread - Application",
        "TimeUnit": "Utility - Application",
        "CoarseChangeFilter": "Data Structure - Application",
        "AutosaveEvent": "Event Handling - Application",
        "BibDatabaseContextChangedEvent": "Event Handling - Application",
        "EventBus": "Event Handling - Application",
        "Subscribe": "User Interface - Search",
        "util": "Utility - Parser",
        "EasyBind": "Utility - Application",
        "PreboundBinding": "Error Handling - Application",
        "Subscription": "Utility - Application",
        "BooleanBinding": "User Interface - Application",
        "ObjectBinding": "User Interface - Application",
        "StringBinding": "User Interface - Application",
        "ListProperty": "User Interface - Application",
        "Property": "User Interface - Utility",
        "ChangeListener": "User Interface - Application",
        "ObservableValue": "User Interface - Application",
        "PseudoClass": "User Interface - Application",
        "Node": "User Interface - Network",
        "Map": "Data Structure - Databases",
        "Consumer": "Language - Utility",
        "Function": "Data Structure - Parser"
    }
}